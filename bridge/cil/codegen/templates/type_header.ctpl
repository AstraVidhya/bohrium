#slurp
#compiler-settings
directiveStartToken = %
#end compiler-settings
%slurp
#region Autogen notice
/****************************************************************
 *         This file is autogenerated, do not modify!           *
 ****************************************************************/
#endregion

#region Copyright
/*
This file is part of Bohrium and copyright (c) 2013 the Bohrium
team <http://www.bh107.org>.

Bohrium is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as 
published by the Free Software Foundation, either version 3 
of the License, or (at your option) any later version.

Bohrium is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the 
GNU Lesser General Public License along with Bohrium. 

If not, see <http://www.gnu.org/licenses/>.
*/
#endregion

using System;
using System.Linq;
using System.Text;
using System.Collections.Generic;
using System.Runtime.InteropServices;

using int8_t = System.SByte;
using uint8_t = System.Byte;
using int16_t = System.Int16;
using uint16_t = System.UInt16;
using int32_t = System.Int32;
using uint32_t = System.UInt32;
using int64_t = System.Int64;
using uint64_t = System.UInt64;

using bh_bool = System.Boolean;
using bh_int8 = System.SByte;
using bh_uint8 = System.Byte;
using bh_int16 = System.Int16;
using bh_uint16 = System.UInt16;
using bh_int32 = System.Int32;
using bh_uint32 = System.UInt32;
using bh_int64 = System.Int64;
using bh_uint64 = System.UInt64;
using bh_float32 = System.Single;
using bh_float64 = System.Double;
using bh_complex64 = NumCIL.Complex64.DataType;
using bh_complex128 = System.Numerics.Complex;

%set $ops = $data[0]
%set $reduce_ops = $data[1]

namespace NumCIL.Bohrium2
{
    %for $ctype, $bh_atype, $bh_ctype, $bh_enum in $ops
    internal partial class DataAccessor_${bh_ctype} : NumCIL.Generic.IDataAccessor<${bh_atype}>, IDisposable
    {

        internal class bh_base_${bh_ctype}_handle : IDisposable
        {
            private DataAccessor_${bh_ctype} m_parent;
            private PInvoke.bh_base_${bh_ctype}_p m_base;
            private bool m_isDisposed = false;

            public bh_base_${bh_ctype}_handle(DataAccessor_${bh_ctype} parent)
            {
                m_parent = parent;
                m_base = m_parent.IncrementRefCount();                                
            }

            /// <summary>
            /// Releases the memory reserved by the pointer
            /// </summary>
            public void Dispose()
            {
                Dispose(true);
            }

            /// <summary>
            /// Releases the memory reserved by the pointer
            /// </summary>
            ~bh_base_${bh_ctype}_handle()
            {
                Dispose(false);
            }

            /// <summary>
            /// Releases the memory reserved by the pointer
            /// </summary>
            protected void Dispose(bool disposing)
            {
                if (m_isDisposed)
                    return;

                if (disposing)
                    GC.SuppressFinalize(this);

                m_isDisposed = true;
                m_parent.DecrementRefCount();
            }

            public static implicit operator PInvoke.bh_base_${bh_ctype}_p(bh_base_${bh_ctype}_handle self)
            {
                if (self.m_isDisposed)
                    throw new ObjectDisposedException(typeof(bh_base_${bh_ctype}_handle).FullName);

                return self.m_base;
            }
        }

        internal PInvoke.bh_base_${bh_ctype}_p Pointer;
        protected ${bh_atype}[] m_data;
        protected readonly long m_size;

        protected object m_lock = new object();
        protected GCHandle m_handle;
        protected long m_refcount;

    
        public DataAccessor_${bh_ctype}(long size)
        {
            m_size = size;
            Pointer = new PInvoke.bh_base_${bh_ctype}_p(size);
        }
        
        public DataAccessor_${bh_ctype}(${bh_atype}[] data)
        {
            if (data == null)
                throw new ArgumentNullException("data");
        
            m_data = data;
            m_size = data.Length;
        }

        internal PInvoke.bh_base_${bh_ctype}_p IncrementRefCount()
        {
            lock (m_lock)
            {
                m_refcount++;
                if (!m_handle.IsAllocated && !Pointer.IsAllocated)
                {
                    m_handle = GCHandle.Alloc(m_data, GCHandleType.Pinned);
                    Pointer = new PInvoke.bh_base_${bh_ctype}_p(m_handle.AddrOfPinnedObject(), m_data.Length);
                }
                
                return Pointer;
            }
        }

        internal bh_base_${bh_ctype}_handle GetPointerHandle()
        {
            return new bh_base_${bh_ctype}_handle(this);
        }

        internal void DecrementRefCount()
        {
            lock (m_lock)
            {
                m_refcount--;
                if (m_refcount <= 0 && m_handle.IsAllocated)
                {
                    m_refcount = 0;
                    m_handle.Free();
                    Pointer.Dispose();
                }
            }
        }    
        #region IDataAccessor implementation

        public ${bh_atype}[] AsArray()
        {
            if (m_data == null)
                Allocate();
            
            return m_data;
        }

        public void Allocate()
        {
            using(var v = new PInvoke.bh_multi_array_${bh_ctype}_p(Pointer))
                v.Sync();

            IntPtr data = Pointer.Data;

            if (m_data == null)
                m_data = new ${bh_atype}[m_size];

            if (data != IntPtr.Zero)
                Utility.WritePointerToArray(data, m_data);

            Pointer.Dispose();
        }

        public long Length
        {
            get
            {
                return m_size;
            }
        }

        public bool IsAllocated
        {
            get
            {
                return m_data != null;
            }
        }

        public ${bh_atype} this[long index]
        {
            get
            {
                //TODO: Can work on pointer...
            
                if (!IsAllocated)
                    Allocate();
                    
                return m_data[index];
            }
            set
            {
                //TODO: Can work on pointer...
                
                if (!IsAllocated)
                    Allocate();
                    
                m_data[index] = value;
            }
        }

        public object Tag { get; set; }


        #endregion

        /// <summary>
        /// Releases the memory reserved by the pointer
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
        }

        /// <summary>
        /// Releases the memory reserved by the pointer
        /// </summary>
        ~DataAccessor_${bh_ctype}()
        {
            Dispose(false);
        }

        /// <summary>
        /// Releases the memory reserved by the pointer
        /// </summary>
        private void Dispose(bool disposing)
        {
            if (disposing)
                GC.SuppressFinalize(this);

            if (Pointer.IsAllocated) 
                Pointer.Dispose();
        }
    }    
    %end for

    internal static partial class PInvoke 
    {
        /// <summary>
        /// Common slice range
        /// </summary>
        public struct bh_slice_range_p
        {
            /// <summary>
            /// The internal pointer instance
            /// </summary>
            #pragma warning disable 0414
            private IntPtr pointer;
            #pragma warning restore 0414

            /// <summary>
            /// Constructs a slice from an IntPtr
            /// </summary>
            public bh_slice_range_p(IntPtr value) { pointer = value; }
            
            /// <summary>
            /// Checks if the array is allocated, i.e. not null
            /// </summary>
            public bool IsAllocated { get { return pointer != IntPtr.Zero; } }
        }

        %for $ctype, $bh_atype, $bh_ctype, $bh_enum in $ops

        /// <summary>
        /// Common base pointer
        /// </summary>
        public struct bh_base_${bh_ctype}_p : IDisposable
        {
            /// <summary>
            /// The internal pointer instance
            /// </summary>
            #pragma warning disable 0414
            private IntPtr pointer;
            #pragma warning restore 0414

            /// <summary>
            /// Constructs a bh_base_${bh_ctype}_p from an IntPtr
            /// </summary>
            public bh_base_${bh_ctype}_p(IntPtr value) { pointer = value; }
            
            /// <summary>
            /// Checks if the array is allocated, i.e. not null
            /// </summary>
            public bool IsAllocated { get { return pointer != IntPtr.Zero; } }

            /// <summary>
            /// Creates a new un-allocated base
            /// </summary>
            public bh_base_${bh_ctype}_p(long size)
            {
                this.pointer = bh_multi_array_${bh_ctype}_create_base(IntPtr.Zero, size).pointer;
            }

            /// <summary>
            /// Creates a new allocated base
            /// </summary>
            public bh_base_${bh_ctype}_p(IntPtr data, long size)
            {
                 this.pointer = bh_multi_array_${bh_ctype}_create_base(data, size).pointer;
            }

            /// <summary>
            /// Gets the data pointer from the base
            /// </summary>
            public IntPtr Data 
            { 
                get { return IsAllocated ? PInvoke.bh_multi_array_${bh_ctype}_get_base_data(this) : IntPtr.Zero; } 
                set { PInvoke.bh_multi_array_${bh_ctype}_set_base_data(this, value); } 
            }
            
            /// <summary>
            /// Gets the data pointer from the base
            /// </summary>
            public long Size { get { return PInvoke.bh_multi_array_${bh_ctype}_get_base_nelem(this); } }

            /// <summary>
            /// Releases the memory reserved by the pointer
            /// </summary>
            public void Dispose()
            {
                /*try { if (IsAllocated) bh_multi_array_${bh_ctype}_destroy_base(this); }
                finally { pointer = IntPtr.Zero; }
                */

                pointer = IntPtr.Zero;
            }
        }


        /// <summary>
        /// The multi-array instance
        /// </summary>
        public struct bh_multi_array_${bh_ctype}_p : IDisposable
        {
            /// <summary>
            /// The internal pointer instance
            /// </summary>
            #pragma warning disable 0414
            private IntPtr pointer;
            #pragma warning restore 0414

            /// <summary>
            /// Constructs a slice from an IntPtr
            /// </summary>
            public bh_multi_array_${bh_ctype}_p(IntPtr value) { pointer = value; }

            /// <summary>
            /// Checks if the array is allocated, i.e. not null
            /// </summary>
            public bool IsAllocated { get { return pointer != IntPtr.Zero; } }

            /// <summary>
            /// Gets or sets the array temp status
            /// </summary>
            public bool Temp
            {
                get { return IsAllocated ? bh_multi_array_${bh_ctype}_get_temp(this) : false; }
                set { bh_multi_array_${bh_ctype}_set_temp(this, value); }
            }

            /// <summary>
            /// Creates a new view
            /// </summary>
            public bh_multi_array_${bh_ctype}_p (NumCIL.Generic.NdArray<${bh_atype}> a)
            {
                var ac = (DataAccessor_${bh_ctype})a.DataAccessor;
                var acp = ac.GetPointerHandle();

                this.pointer = bh_multi_array_${bh_ctype}_new_from_view(
                    acp, 
                    a.Shape.Dimensions.Length, 
                    a.Shape.Offset, 
                    a.Shape.Dimensions.Select(x => x.Length).ToArray(),
                    a.Shape.Dimensions.Select(x => x.Stride).ToArray()
                ).pointer;
            }

            /// <summary>
            /// Creates a new view from base
            /// </summary>
            public bh_multi_array_${bh_ctype}_p (bh_base_${bh_ctype}_p @base)
            {
                this.pointer = bh_multi_array_${bh_ctype}_new_from_base(@base).pointer;
            }

            /// <summary>
            /// Releases the memory reserved by the pointer
            /// </summary>
            public void Dispose()
            {
                try { if (IsAllocated) bh_multi_array_${bh_ctype}_destroy(this); }
                finally { pointer = IntPtr.Zero; }
            }

            /// <summary>
            /// Gets the base for a multi-array
            /// </summary>
            public bh_base_${bh_ctype}_p Base
            {
                get { return bh_multi_array_${bh_ctype}_get_base(this); }
            }

            /// <summary>
            /// Gets the base for a multi-array
            /// </summary>
            public void Sync()
            {
                bh_multi_array_${bh_ctype}_sync(this);
            }
        }

        /// <summary>
        /// Common slice range
        /// </summary>
        public struct bh_slice_range_${bh_ctype}_p 
        {
            /// <summary>
            /// The internal pointer instance
            /// </summary>
            #pragma warning disable 0414
            private IntPtr pointer;
            #pragma warning restore 0414

            /// <summary>
            /// Constructs a slice from an IntPtr
            /// </summary>
            public bh_slice_range_${bh_ctype}_p(IntPtr value) { pointer = value; }
            
            /// <summary>
            /// Checks if the array is allocated, i.e. not null
            /// </summary>
            public bool IsAllocated { get { return pointer != IntPtr.Zero; } }
        }

        /// <summary>
        /// Create a base pointer from existing data
        /// </summary>
        [DllImport("libbhc", SetLastError = true, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Auto)]
        public extern static bh_base_${bh_ctype}_p bh_multi_array_${bh_ctype}_create_base(IntPtr data, int64_t nelem);

        /// <summary>
        /// Destroy a base pointer
        /// </summary>
        [DllImport("libbhc", SetLastError = true, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Auto)]
        public extern static void bh_multi_array_${bh_ctype}_destroy_base(bh_base_${bh_ctype}_p @base);

        /// <summary>
        /// Gets the data pointer from a base
        /// </summary>
        [DllImport("libbhc", SetLastError = true, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Auto)]
        public extern static IntPtr bh_multi_array_${bh_ctype}_get_base_data([In] bh_base_${bh_ctype}_p @base);

        /// <summary>
        /// Gets the number of elements in a base
        /// </summary>        
        [DllImport("libbhc", SetLastError = true, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Auto)]
        public extern static int64_t bh_multi_array_${bh_ctype}_get_base_nelem([In] bh_base_${bh_ctype}_p @base);

        /// <summary>
        /// Sets the data pointer for a base
        /// </summary>
        public extern static void bh_multi_array_${bh_ctype}_set_base_data(bh_base_${bh_ctype}_p @base, IntPtr data);

        /// <summary>
        /// Sets the temp status of an array
        /// </summary>        
        [DllImport("libbhc", SetLastError = true, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Auto)]
        public extern static void bh_multi_array_${bh_ctype}_set_temp([In] bh_multi_array_${bh_ctype}_p self, bh_bool temp);

        /// <summary>
        /// Sets the temp status of an array
        /// </summary>        
        [DllImport("libbhc", SetLastError = true, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Auto)]
        public extern static bh_bool bh_multi_array_${bh_ctype}_get_temp([In] bh_multi_array_${bh_ctype}_p self);

        /// <summary>
        /// Construct a new array from bh_base_${bh_ctype}_p and view setup
        /// </summary>
        [DllImport("libbhc", SetLastError = true, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Auto)]
        public extern static bh_multi_array_${bh_ctype}_p bh_multi_array_${bh_ctype}_new_from_view([In] bh_base_${bh_ctype}_p @base, [In] int64_t rank, [In] int64_t start, [In] int64_t[] shape, [In] int64_t[] stride);

        /// <summary>
        /// Construct a new array from bh_base_${bh_ctype}_p and view setup
        /// </summary>
        [DllImport("libbhc", SetLastError = true, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Auto)]
        public extern static bh_multi_array_${bh_ctype}_p bh_multi_array_${bh_ctype}_new_from_base([In] bh_base_${bh_ctype}_p @base);

        /// <summary>
        /// Construct a new empty array
        /// </summary>
        [DllImport("libbhc", SetLastError = true, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Auto)]
        public extern static bh_multi_array_${bh_ctype}_p bh_multi_array_${bh_ctype}_new_empty([In] int64_t rank, [In] int64_t[] shape);

        /// <summary>
        /// Construct a new zero-filled array
        /// </summary>
        [DllImport("libbhc", SetLastError = true, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Auto)]
        public extern static bh_multi_array_${bh_ctype}_p bh_multi_array_${bh_ctype}_new_zeroes([In] int64_t rank, [In] int64_t[] shape);

        /// <summary>
        /// Construct a new one-filled array
        /// </summary>
        [DllImport("libbhc", SetLastError = true, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Auto)]
        public extern static bh_multi_array_${bh_ctype}_p bh_multi_array_${bh_ctype}_new_ones([In] int64_t rank, [In] int64_t[] shape);

        /// <summary>
        /// Construct a new array with sequential numbers
        /// </summary>
        [DllImport("libbhc", SetLastError = true, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Auto)]
        public extern static bh_multi_array_${bh_ctype}_p bh_multi_array_${bh_ctype}_new_range([In] int64_t start, [In] int64_t end, [In] int64_t skip);

        /// <summary>
        /// Construct a new random-filled array
        /// </summary>
        [DllImport("libbhc", SetLastError = true, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Auto)]
        public extern static bh_multi_array_${bh_ctype}_p bh_multi_array_${bh_ctype}_new_random([In] int64_t length);

        /// <summary>
        /// Construct a new array, filled with the specified value
        /// </summary>
        [DllImport("libbhc", SetLastError = true, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Auto)]
        public extern static bh_multi_array_${bh_ctype}_p bh_multi_array_${bh_ctype}_new_value([In] ${bh_atype} value, [In] int64_t rank, [In] int64_t[] shape);

        /// <summary>
        /// Synchronizes the current base
        /// </summary>
        [DllImport("libbhc", SetLastError = true, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Auto)]
        public extern static bh_base_${bh_ctype}_p bh_multi_array_${bh_ctype}_sync([In] bh_multi_array_${bh_ctype}_p self);

        /// <summary>
        /// Gets the base from an existing array
        /// </summary>
        [DllImport("libbhc", SetLastError = true, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Auto)]
        public extern static bh_base_${bh_ctype}_p bh_multi_array_${bh_ctype}_get_base([In] bh_multi_array_${bh_ctype}_p self);

        /// <summary>
        /// Construct a copy of the array
        /// </summary>
        [DllImport("libbhc", SetLastError = true, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Auto)]
        public extern static bh_multi_array_${bh_ctype}_p bh_multi_array_${bh_ctype}_new_copy(bh_multi_array_${bh_ctype}_p other);

        /// <summary>
        /// Destroy the pointer and release resources
        /// </summary>
        [DllImport("libbhc", SetLastError = true, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Auto)]
        public extern static void bh_multi_array_${bh_ctype}_destroy(bh_multi_array_${bh_ctype}_p self);

        /// <summary>
        /// Gets the number of elements in the array
        /// </summary>
        [DllImport("libbhc", SetLastError = true, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Auto)]
        public extern static uint64_t bh_multi_array_${bh_ctype}_get_length(bh_multi_array_${bh_ctype}_p self);

        /// <summary>
        /// Gets the number of dimensions in the array
        /// </summary>
        [DllImport("libbhc", SetLastError = true, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Auto)]
        public extern static uint64_t bh_multi_array_${bh_ctype}_get_rank(bh_multi_array_${bh_ctype}_p self);

        /// <summary>
        /// Gets the number of elements in the dimension
        /// </summary>
        [DllImport("libbhc", SetLastError = true, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Auto)]
        public extern static uint64_t bh_multi_array_${bh_ctype}_get_dimension_size(bh_multi_array_${bh_ctype}_p self, [In] int64_t dimension);

        /// <summary>
        /// Update with a scalar
        /// </summary>
        [DllImport("libbhc", SetLastError = true, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Auto)]
        public extern static void bh_multi_array_${bh_ctype}_assign_scalar(bh_multi_array_${bh_ctype}_p self, [In] ${bh_atype} value);

        /// <summary>
        /// Update with an array
        /// </summary>
        [DllImport("libbhc", SetLastError = true, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Auto)]
        public extern static void bh_multi_array_${bh_ctype}_assign_array(bh_multi_array_${bh_ctype}_p self, bh_multi_array_${bh_ctype}_p other);

        /// <summary>
        /// Flatten view
        /// </summary>
        [DllImport("libbhc", SetLastError = true, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Auto)]
        public extern static bh_multi_array_${bh_ctype}_p bh_multi_array_${bh_ctype}_flatten(bh_multi_array_${bh_ctype}_p self);

        /// <summary>
        /// Transpose view
        /// </summary>
        [DllImport("libbhc", SetLastError = true, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Auto)]
        public extern static bh_multi_array_${bh_ctype}_p bh_multi_array_${bh_ctype}_transpose(bh_multi_array_${bh_ctype}_p self);

        %for $opname, $enum in $reduce_ops
        /// <summary>
        /// Partial ${opname} reduction 
        /// </summary>
        [DllImport("libbhc", SetLastError = true, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Auto)]
        public extern static bh_multi_array_${bh_ctype}_p bh_multi_array_${bh_ctype}_partial_reduce_${opname}(bh_multi_array_${bh_ctype}_p self, [In] int64_t axis);

        %end for

        /// <summary>
        /// Sum
        /// </summary>
        [DllImport("libbhc", SetLastError = true, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Auto)]
        public extern static ${bh_atype} bh_multi_array_${bh_ctype}_sum(bh_multi_array_${bh_ctype}_p self);

        /// <summary>
        /// Product
        /// </summary>
        [DllImport("libbhc", SetLastError = true, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Auto)]
        public extern static ${bh_atype} bh_multi_array_${bh_ctype}_product(bh_multi_array_${bh_ctype}_p self);

        /// <summary>
        /// Max
        /// </summary>
        [DllImport("libbhc", SetLastError = true, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Auto)]
        public extern static ${bh_atype} bh_multi_array_${bh_ctype}_max(bh_multi_array_${bh_ctype}_p self);

        /// <summary>
        /// Min
        /// </summary>
        [DllImport("libbhc", SetLastError = true, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Auto)]
        public extern static ${bh_atype} bh_multi_array_${bh_ctype}_min(bh_multi_array_${bh_ctype}_p self);

        %end for
    }
}
/*
This file is part of Bohrium and copyright (c) 2012 the Bohrium
team <http://www.bh107.org>.

Bohrium is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation, either version 3
of the License, or (at your option) any later version.

Bohrium is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the
GNU Lesser General Public License along with Bohrium.

If not, see <http://www.gnu.org/licenses/>.
*/

#include <Python.h>

#if PY_MAJOR_VERSION >= 3
#define NPY_PY3K
#endif

#define BhAPI_MODULE

#include <bohrium_api.h>  // Notice, `bohrium_api.h` is auto generated by `setup.py`
#include <bhc.h>

/// Handles both PyLong and PyInt. Notice that `PyLong_AsLong*()` supports both PyLong and PyInt
int PyInteger_Check(PyObject *item) {
#ifdef NPY_PY3K
    return PyLong_Check(item);
#else
    return PyLong_Check(item) || PyInt_Check(item); // Python2 also has PyInt
#endif
}


/** Notice, all functions starting with `BhAPI_` will be part of the auto generated C-API.
 *  See the `write_header()` function in `setup.py`
 */

/// Flush the Bohrium runtime system
static void BhAPI_flush(void) {
    bhc_flush();
}

PyObject *PyAPI_flush(PyObject *self, PyObject *args) {
    BhAPI_flush();
    Py_RETURN_NONE;
}

/// Get the number of times flush has been called
static int BhAPI_flush_count(void) {
    return bhc_flush_count();
}

/// Flush and repeat the lazy evaluated operations `nrepeats` times.
static void BhAPI_flush_and_repeat(uint64_t nrepeats) {
    bhc_flush_and_repeat(nrepeats);
}

/// Flush and repeat the lazy evaluated operations until `condition` is false or `nrepeats` is reached.
static void BhAPI_flush_and_repeat_condition(uint64_t nrepeats, bhc_ndarray_bool8_p condition) {
    bhc_flush_and_repeat_condition(nrepeats, condition);
}

/// Send and receive a message through the component stack
/// NB: the returned string is invalidated on the next call to BhAPI_message()
static const char *BhAPI_message(const char *msg) {
    return bhc_message(msg);
}

PyObject *PyAPI_message(PyObject *self, PyObject *args, PyObject *kwds) {
    char *msg;
    static char *kwlist[] = {"msg:str", NULL};
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "s", kwlist, &msg)) {
        return NULL;
    }
#if defined(NPY_PY3K)
    return PyUnicode_FromString(bhc_message(msg));
#else
    return PyString_FromString(bhc_message(msg));
#endif
}

/// Get the device context, such as OpenCL's cl_context, of the first VE in the runtime stack.
/// If the first VE isn't a device, NULL is returned.
static void *BhAPI_getDeviceContext(void) {
    return bhc_getDeviceContext();
}

/// Set the context handle, such as CUDA's context, of the first VE in the runtime stack.
/// If the first VE isn't a device, nothing happens.
static void BhAPI_set_device_context(uint64_t device_context) {
    bhc_set_device_context(device_context);
}

/// Create new flat array
static void *BhAPI_new(bhc_dtype dtype, uint64_t size) {
    return bhc_new(dtype, size);
};

static PyObject *PyAPI_new(PyObject *self, PyObject *args, PyObject *kwds) {
    int dtype;
    Py_ssize_t nelem;
    static char *kwlist[] = {"dtype:int", "nelem:int", NULL};
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "in", kwlist, &dtype, &nelem)) {
        return NULL;
    }
    if (dtype < 0 || dtype > BH_COMPLEX128) {
        PyErr_Format(PyExc_TypeError, "dtype unknown");
        return NULL;
    }
    if (nelem <= 0) {
        PyErr_Format(PyExc_OverflowError, "api_new(): nelem must be a integer greater than zero");
        return NULL;
    }
    void *array_handle = BhAPI_new(dtype, (uint64_t) nelem);
    if (array_handle == NULL) {
        PyErr_Format(PyExc_RuntimeError, "BhAPI_new() failed");
        return NULL;
    }
    PyObject *obj = PyCapsule_New(array_handle, "bhc_ary_ptr", NULL);
    if (obj == NULL) {
        return NULL;
    }
    return obj;
}

/// Destroy array
static void BhAPI_destroy(bhc_dtype dtype, void *ary) {
    bhc_destroy(dtype, ary);
};

static PyObject *PyAPI_destroy(PyObject *self, PyObject *args, PyObject *kwds) {
    bhc_dtype dtype;
    PyObject *ary_capsule;
    static char *kwlist[] = {"dtype:int", "bhc_ary_ptr:PyCapsule", NULL};
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "iO", kwlist, &dtype, &ary_capsule)) {
        return NULL;
    }
    if (dtype < 0 || dtype > BH_COMPLEX128) {
        PyErr_Format(PyExc_TypeError, "dtype unknown");
        return NULL;
    }
    if (!PyCapsule_IsValid(ary_capsule, "bhc_ary_ptr")) {
        PyErr_Format(PyExc_RuntimeError, "second argument must be a PyCapsule named 'bhc_ary_ptr'");
        return NULL;
    }
    void *array_handle = PyCapsule_GetPointer(ary_capsule, "bhc_ary_ptr");
    if (array_handle == NULL) {
        return NULL;
    }
    bhc_destroy(dtype, array_handle);
    Py_RETURN_NONE;
}

/// Create view of a flat array `src`
static void *BhAPI_view(bhc_dtype dtype, void *src, int64_t rank, int64_t start, const int64_t *shape,
                        const int64_t *stride) {
    return bhc_view(dtype, src, rank, start, shape, stride);
}

static PyObject *PyAPI_view(PyObject *self, PyObject *args, PyObject *kwds) {
    int dtype, rank;
    int64_t start;
    PyObject *src_capsule, *shape_list, *stride_list;
    void *src;
    static char *kwlist[] = {"dtype:int", "src:PyCapsule", "rank:int", "start:int", "shape:list", "stride:list", NULL};
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "iOiLOO", kwlist, &dtype, &src_capsule, &rank, &start, &shape_list,
                                     &stride_list)) {
        return NULL;
    }
    if (dtype < 0 || dtype > BH_COMPLEX128) {
        PyErr_Format(PyExc_TypeError, "dtype unknown");
        return NULL;
    }
    if (PyCapsule_IsValid(src_capsule, "bhc_ary_ptr")) {
        src = PyCapsule_GetPointer(src_capsule, "bhc_ary_ptr");
    } else {
        PyErr_Format(PyExc_RuntimeError, "second argument must be a PyCapsule named 'bhc_ary_ptr'");
        return NULL;
    }
    int ndim = PyList_Size(shape_list);
    if (ndim != PyList_Size(stride_list)) {
        PyErr_Format(PyExc_RuntimeError, "shape and stride must have same length");
        return NULL;
    }
    int64_t shape[ndim];
    for (int i = 0; i < ndim; ++i) {
        PyObject *item = PyList_GetItem(shape_list, i);
        if (item == NULL) {
            return NULL;
        }
        shape[i] = PyLong_AsLongLong(item);
        if (PyErr_Occurred()) {
            PyErr_Clear();
            PyErr_Format(PyExc_TypeError, "shape must be integers");
            return NULL;
        }
    }
    int64_t stride[ndim];
    for (int i = 0; i < ndim; ++i) {
        PyObject *item = PyList_GetItem(stride_list, i);
        if (item == NULL) {
            return NULL;
        }
        stride[i] = PyLong_AsLongLong(item);
        if (PyErr_Occurred()) {
            PyErr_Clear();
            PyErr_Format(PyExc_TypeError, "stride must be integers");
            return NULL;
        }
    }
    void *array_handle = bhc_view(dtype, src, rank, start, shape, stride);
    if (array_handle == NULL) {
        PyErr_Format(PyExc_RuntimeError, "BhAPI_view() failed");
        return NULL;
    }
    PyObject *obj = PyCapsule_New(array_handle, "bhc_ary_ptr", NULL);
    if (obj == NULL) {
        return NULL;
    }
    return obj;
}

/// Informs the runtime system to make data synchronized and available after the next flush().
static void BhAPI_sync(bhc_dtype dtype, const void *ary) {
    bhc_sync(dtype, ary);
}

/// Set a reset for an iterator in a dynamic view within a loop
static void BhAPI_add_reset(bhc_dtype dtype, const void *ary1, size_t dim, size_t reset_max) {
    bhc_add_reset(dtype, ary1, dim, reset_max);
}

/// Do array operation based on `opcode`
static void BhAPI_op(bhc_opcode opcode, const bhc_dtype types[], const bhc_bool constants[], void *operands[]) {
    bhc_op(opcode, types, constants, operands);
}

static PyObject *PyAPI_op(PyObject *self, PyObject *args, PyObject *kwds) {
    bhc_opcode opcode;
    PyObject *dtype_list, *operand_list;
    static char *kwlist[] = {"opcode", "dtype_list:list", "operand_list:list", NULL};
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "iOO", kwlist, &opcode, &dtype_list, &operand_list)) {
        return NULL;
    }
    int nop = PyList_Size(dtype_list);
    if (nop != PyList_Size(operand_list)) {
        PyErr_Format(PyExc_RuntimeError, "dtype_list and operand_list must have same length");
        return NULL;
    }
    bhc_dtype dtypes[nop];
    for (int i = 0; i < nop; ++i) {
        PyObject *item = PyList_GetItem(dtype_list, i);
        if (!PyInteger_Check(item)) {
            PyErr_Format(PyExc_TypeError, "dtype_list must be integers");
            return NULL;
        }
        dtypes[i] = PyLong_AsLong(item);
        if (PyErr_Occurred()) {
            return NULL;
        }
        if (dtypes[i] < 0 || dtypes[i] > BH_COMPLEX128) {
            PyErr_Format(PyExc_TypeError, "unknown dtype");
            return NULL;
        }
    }
    bhc_bool is_constant_list[nop];
    void *operands[nop];
    bhc_scalar_union constant;
    for (int i = 0; i < nop; ++i) {
        PyObject *item = PyList_GetItem(operand_list, i);
        if (PyInteger_Check(item)) {
            long long scalar = PyLong_AsLongLong(item);
            if (PyErr_Occurred()) {
                return NULL;
            }
            switch (dtypes[i]) {
                case BH_BOOL:
                    constant.bool8 = scalar;
                    break;
                case BH_INT8:
                    constant.int8 = scalar;
                    break;
                case BH_INT16:
                    constant.int16 = scalar;
                    break;
                case BH_INT32:
                    constant.int32 = scalar;
                    break;
                case BH_INT64:
                    constant.int64 = scalar;
                    break;
                case BH_UINT8:
                    constant.uint8 = scalar;
                    break;
                case BH_UINT16:
                    constant.uint16 = scalar;
                    break;
                case BH_UINT32:
                    constant.uint32 = scalar;
                    break;
                case BH_UINT64:
                    constant.uint64 = scalar;
                    break;
                default:
                    PyErr_Format(PyExc_TypeError, "the type of each item in operand_list must match dtype_list");
                    return NULL;
            }
            is_constant_list[i] = 1;
            operands[i] = &constant;
        } else if (PyFloat_Check(item)) {
            double scalar = PyFloat_AsDouble(item);
            if (PyErr_Occurred()) {
                return NULL;
            }
            switch (dtypes[i]) {
                case BH_FLOAT32:
                    constant.float32 = scalar;
                    break;
                case BH_FLOAT64:
                    constant.float64 = scalar;
                    break;
                default:
                    PyErr_Format(PyExc_TypeError, "the type of each item in operand_list must match dtype_list");
                    return NULL;
            }
            is_constant_list[i] = 1;
            operands[i] = &constant;
        } else if (PyComplex_Check(item)) {
            Py_complex scalar = PyComplex_AsCComplex(item);
            if (PyErr_Occurred()) {
                return NULL;
            }
            switch (dtypes[i]) {
                case BH_COMPLEX64:
                    constant.complex64.real = scalar.real;
                    constant.complex64.imag = scalar.imag;
                    break;
                case BH_COMPLEX128:
                    constant.complex128.real = scalar.real;
                    constant.complex128.imag = scalar.imag;
                    break;
                default:
                    PyErr_Format(PyExc_TypeError, "the type of each item in operand_list must match dtype_list");
                    return NULL;
            }
            is_constant_list[i] = 1;
            operands[i] = &constant;
        } else if (PyCapsule_IsValid(item, "bhc_ary_ptr")) {
            operands[i] = PyCapsule_GetPointer(item, "bhc_ary_ptr");
            if (operands[i] == NULL) {
                return NULL;
            }
            is_constant_list[i] = 0;
        } else {
            PyErr_Format(PyExc_RuntimeError,
                         "operand_list[%d] must be a Python scalar or a PyCapsule named 'bhc_ary_ptr'", i);
            return NULL;
        }
    }
    bhc_op(opcode, dtypes, is_constant_list, operands);
    Py_RETURN_NONE;
}

/** Fill out with random data.
  The returned result is a deterministic function of the key and counter,
  i.e. a unique (seed, indexes) tuple will always produce the same result.
  The result is highly sensitive to small changes in the inputs, so that the sequence
  of values produced by simply incrementing the counter (or key) is effectively
  indistinguishable from a sequence of samples of a uniformly distributed random variable.

  random123(out, seed, key) where: 'out' is the array to fill with random data
                                   'seed' is the seed of a random sequence
                                   'key' is the index in the random sequence
*/
static void BhAPI_random123(void *out, uint64_t seed, uint64_t key) {
    bhc_random123_Auint64_Kuint64_Kuint64(out, seed, key);
}

static PyObject *PyAPI_random123(PyObject *self, PyObject *args, PyObject *kwds) {
    PyObject *ary_capsule;
    Py_ssize_t seed, key;
    static char *kwlist[] = {"bhc_ary_ptr:PyCapsule", "seed:int", "key:int", NULL};
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "Onn", kwlist, &ary_capsule, &seed, &key)) {
        return NULL;
    }
    if (!PyCapsule_IsValid(ary_capsule, "bhc_ary_ptr")) {
        PyErr_Format(PyExc_RuntimeError, "second argument must be a PyCapsule named 'bhc_ary_ptr'");
        return NULL;
    }
    void *array_handle = PyCapsule_GetPointer(ary_capsule, "bhc_ary_ptr");
    if (array_handle == NULL) {
        return NULL;
    }
    BhAPI_random123(array_handle, seed, key);
    Py_RETURN_NONE;
}

/// Extension Method, returns 0 when the extension exist
static int BhAPI_extmethod(bhc_dtype dtype, const char *name, const void *out, const void *in1, const void *in2) {
    return bhc_extmethod(dtype, name, out, in1, in2);
}

/// Get data pointer from the first VE in the runtime stack
///   if 'copy2host', always copy the memory to main memory
///   if 'force_alloc', force memory allocation before returning the data pointer
///   if 'nullify', set the data pointer to NULL after returning the data pointer
static void *BhAPI_data_get(bhc_dtype dtype, const void *ary, bhc_bool copy2host, bhc_bool force_alloc,
                            bhc_bool nullify) {
    return bhc_data_get(dtype, ary, copy2host, force_alloc, nullify);
}

static PyObject *PyAPI_data_get(PyObject *self, PyObject *args, PyObject *kwds) {
    bhc_dtype dtype;
    PyObject *ary_capsule;
    int copy2host, force_alloc, nullify;
    Py_ssize_t nbytes;
    static char *kwlist[] = {"dtype:int", "bhc_ary_ptr:PyCapsule", "copy2host:bool",
                             "force_alloc:bool", "nullify:bool", "nbytes:int", NULL};
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "iOiiin", kwlist, &dtype, &ary_capsule, &copy2host, &force_alloc,
                                     &nullify, &nbytes)) {
        return NULL;
    }
    if (dtype < 0 || dtype > BH_COMPLEX128) {
        PyErr_Format(PyExc_TypeError, "dtype unknown");
        return NULL;
    }
    if (!PyCapsule_IsValid(ary_capsule, "bhc_ary_ptr")) {
        PyErr_Format(PyExc_RuntimeError, "second argument must be a PyCapsule named 'bhc_ary_ptr'");
        return NULL;
    }
    void *array_handle = PyCapsule_GetPointer(ary_capsule, "bhc_ary_ptr");
    if (array_handle == NULL) {
        return NULL;
    }
    void *data = bhc_data_get(dtype, array_handle, copy2host, force_alloc, nullify);
    if (data == NULL) {
        Py_RETURN_NONE;
    } else {
        #ifdef NPY_PY3K
            Py_buffer buf_info;
            PyBuffer_FillInfo(&buf_info, NULL, data, nbytes, 0, PyBUF_CONTIG);
            return PyMemoryView_FromBuffer(&buf_info);
        #else
            return PyBuffer_FromReadWriteMemory(data, nbytes);
        #endif
    }
}


/// Set data pointer in the first VE in the runtime stack
/// NB: The component will deallocate the memory when encountering a BH_FREE
///   if 'host_ptr', the pointer points to the host memory (main memory) as opposed to device memory
static void BhAPI_data_set(bhc_dtype dtype, const void *ary, bhc_bool host_ptr, void *data) {
    bhc_data_set(dtype, ary, host_ptr, data);
}

/// Copy the memory of `src` to `dst`
///   Use 'param' to set compression parameters or use the empty string
static void BhAPI_data_copy(bhc_dtype dtype, const void *src, const void *dst, const char *param) {
    bhc_data_copy(dtype, src, dst, param);
}


PyObject* BhAPI_copy_from_memory_view(PyObject *self, PyObject *args, PyObject *kwds) {
    bhc_dtype dtype;
    PyObject *ary_capsule;
    PyObject *memoryview;
    static char *kwlist[] = {"dtype:int", "bhc_ary_ptr:PyCapsule", "buf:memoryview", NULL};
    if (!PyArg_ParseTupleAndKeywords(args, kwds, "iOO", kwlist, &dtype, &ary_capsule, &memoryview)) {
        return NULL;
    }
    if (dtype < 0 || dtype > BH_COMPLEX128) {
        PyErr_Format(PyExc_TypeError, "dtype unknown");
        return NULL;
    }
    if (!PyCapsule_IsValid(ary_capsule, "bhc_ary_ptr")) {
        PyErr_Format(PyExc_RuntimeError, "second argument must be a PyCapsule named 'bhc_ary_ptr'");
        return NULL;
    }
    if (!PyMemoryView_Check(memoryview)) {
        PyErr_Format(PyExc_TypeError, "third argument must be a memoryview object.");
        return NULL;
    }
    void *array_handle = PyCapsule_GetPointer(ary_capsule, "bhc_ary_ptr");
    if (array_handle == NULL) {
        return NULL;
    }

    Py_buffer *buf = PyMemoryView_GET_BUFFER(memoryview);

    // bhc_data_get(dtype=dtype, ary=array_handle, copy2host=True, force_alloc=True, nullify=False);
    void *dest = bhc_data_get(dtype, array_handle, 1, 1, 0);
    
    memcpy(dest, buf->buf, buf->len);
    Py_RETURN_NONE;
}


/// Slides the view of an array in the given dimensions, by the given strides for each iteration in a loop.
static void BhAPI_slide_view(bhc_dtype dtype, const void *ary1, size_t dim, int slide, int view_shape, int array_shape,
                             int array_stride, int step_delay) {
    bhc_slide_view(dtype, ary1, dim, slide, view_shape, array_shape, array_stride, step_delay);
}

/** Init arrays and signal handler */
static void BhAPI_mem_signal_init(void) {
    bh_mem_signal_init();
}

/** Shutdown of this library */
static void BhAPI_mem_signal_shutdown(void) {
    bh_mem_signal_shutdown();
}

/** Attach continues memory segment to signal handler
 *
 * @param idx - Id to identify the memory segment when executing the callback function.
 * @param addr - Start address of memory segment.
 * @param size - Size of memory segment in bytes
 * @param callback - Callback function which is executed when segfault hits in the memory
 *                   segment. The function is called with the address pointer and the memory segment idx.
 *                   NB: the function must return non-zero on success
 */
static void BhAPI_mem_signal_attach(void *idx, void *addr, uint64_t size,
                                    int (*callback)(void *fault_address, void *segment_idx)) {
    bh_mem_signal_attach(idx, addr, size, callback);
}

/** Detach signal
 *
 * @param addr - Start address of memory segment.
 */
static void BhAPI_mem_signal_detach(const void *addr) {
    bh_mem_signal_detach(addr);
}

/** Check if signal exist
 *
 * @param addr - Start address of memory segment.
 */
static int BhAPI_mem_signal_exist(const void *addr) {
    return bh_mem_signal_exist(addr);
}

/** Run a user kernel
 *
 * @param kernel The source code of the kernel
 * @param nop Number of operands
 * @param operands The operands given to the kernel all of which must be regular arrays
 * @param compile_cmd The compilation command
 * @param tag String that define which component that should handle this kernel (e.g. "openmp", "opencl", or "cuda")
 * @param param Backend specific parameters (e.g. OpenCL needs `global_work_size` and `local_work_size`)
 * @return The compiler output (both stdout and stderr) when the compilation fails else it is the empty string
 */
static const char* BhAPI_user_kernel(const char* kernel, int nop, void *operands[],
                                     const char* compile_cmd, const char* tag, const char* param) {
    return bhc_user_kernel(kernel, nop, operands, compile_cmd, tag, param);
}

PyObject *PySanityCheck(PyObject *self, PyObject *args) {
    bhc_ndarray_uint64_p a = bhc_new_Auint64(100);
    bhc_ndarray_uint64_p b = bhc_new_Auint64(1);
    bhc_range_Auint64(a);
    bhc_add_reduce_Auint64_Auint64_Kint64(b, a, 0);
    BhAPI_flush();
    uint64_t *b_data = (uint64_t *) bhc_data_get_Auint64(b, 1, 1, 0);
    int success = (4950 == *b_data);  // The sum of 0..100 is 4950.
    bhc_destroy_Auint64(a);
    bhc_destroy_Auint64(b);
    BhAPI_flush();
    if (success) {
        Py_RETURN_TRUE;
    } else {
        Py_RETURN_FALSE;
    }
}

// The methods (functions) of this module
static PyMethodDef _bh_apiMethods[] = {
        {"flush",        PyAPI_flush,                  METH_NOARGS,                  "Evaluate all delayed array operations"},
        {"sanity_check", PySanityCheck,                METH_NOARGS,                  "Check the Bohrium API installation (returns a boolean)."},
        {"message",      (PyCFunction) PyAPI_message,  METH_VARARGS |
                                                       METH_KEYWORDS,                "Send and receive a message through the Bohrium stack"},
        {"new",          (PyCFunction) PyAPI_new,      METH_VARARGS | METH_KEYWORDS, ""},
        {"view",         (PyCFunction) PyAPI_view,     METH_VARARGS | METH_KEYWORDS, ""},
        {"destroy",      (PyCFunction) PyAPI_destroy,  METH_VARARGS | METH_KEYWORDS, ""},
        {"op",           (PyCFunction) PyAPI_op,       METH_VARARGS | METH_KEYWORDS, ""},
        {"data_get",     (PyCFunction) PyAPI_data_get, METH_VARARGS | METH_KEYWORDS, ""},
        {"copy_from_memory_view",
         (PyCFunction) BhAPI_copy_from_memory_view, METH_VARARGS | METH_KEYWORDS, ""},
        {"random123",     (PyCFunction) PyAPI_random123, METH_VARARGS | METH_KEYWORDS, ""},
        {NULL,           NULL,                         0,                            NULL}        /* Sentinel */
};

#if defined(NPY_PY3K)
static struct PyModuleDef moduledef = {
    PyModuleDef_HEAD_INIT,
    "_bh_api",/* name of module */
    NULL, /* module documentation, may be NULL */
    -1,   /* size of per-interpreter state of the module or -1 if the module keeps state in global variables. */
    _bh_apiMethods /* the methods of this module */
};
#endif

#if defined(NPY_PY3K)
#define RETVAL m
PyMODINIT_FUNC PyInit__bh_api(void)
#else
#define RETVAL

PyMODINIT_FUNC init_bh_api(void)
#endif
{
    static void *PyBhAPI[BhAPI_num_of_pointers];
    PyObject *c_api_object;
    PyObject *m;
#if defined(NPY_PY3K)
    m = PyModule_Create(&moduledef);
#else
    m = Py_InitModule("_bh_api", _bh_apiMethods);
#endif
    if (m == NULL) {
        return RETVAL;
    }

    /* Initialize `PyBhAPI` */
    init_c_api_struct(PyBhAPI);

    /* Create a Capsule containing the API pointer array's address */
    c_api_object = PyCapsule_New((void *) PyBhAPI, "bohrium_api._C_API", NULL);
    if (c_api_object != NULL)
        PyModule_AddObject(m, "_C_API", c_api_object);

    PyModule_AddIntConstant(m, "bool", BH_BOOL);
    PyModule_AddIntConstant(m, "int8", BH_INT8);
    PyModule_AddIntConstant(m, "int16", BH_INT16);
    PyModule_AddIntConstant(m, "int32", BH_INT32);
    PyModule_AddIntConstant(m, "int64", BH_INT64);
    PyModule_AddIntConstant(m, "uint8", BH_UINT8);
    PyModule_AddIntConstant(m, "uint16", BH_UINT16);
    PyModule_AddIntConstant(m, "uint32", BH_UINT32);
    PyModule_AddIntConstant(m, "uint64", BH_UINT64);
    PyModule_AddIntConstant(m, "float32", BH_FLOAT32);
    PyModule_AddIntConstant(m, "float64", BH_FLOAT64);
    PyModule_AddIntConstant(m, "complex64", BH_COMPLEX64);
    PyModule_AddIntConstant(m, "complex128", BH_COMPLEX128);
    return RETVAL;
}

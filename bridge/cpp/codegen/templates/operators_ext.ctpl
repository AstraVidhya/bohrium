#slurp
#compiler-settings
directiveStartToken = %
#end compiler-settings
%slurp
//
//  Binary operators such as:
//  Mapping "a + b" to BH_ADD(t, a, b)
//  Mapping "a + 1.0" to BH_ADD(t, a, 1.0)
//  Mapping "1.0 + a" to BH_ADD(t, 1.0, a)
//
%for $op, $opcode, $optype, $opcount in $data
%if $optype == "operator.ext" and $opcode != "CUSTOM" and $opcount == 3

template <typename T>
multi_array<T>& operator$op (multi_array<T>& lhs, multi_array<T>& rhs)
{
    multi_array<T>* operand = new multi_array<T>( lhs );
    operand->setTemp(true);

    if (!compatible_shape(lhs, rhs)) {
        std::cout << "Incompatible shape, possibly broadcastable." << std::endl;
        // Create a view pointing to rhs with broadcasted shape and fixed strides.
    }

    // shape of "operand" should be defined by broadcast

    Runtime::instance()->enqueue((bh_opcode)$opcode, *operand, lhs, rhs);

    return *operand;
}

template <typename T>
multi_array<T> & operator$op (multi_array<T>& lhs, const T& rhs)
{
    multi_array<T>* operand = new multi_array<T>( lhs );
    operand->setTemp(true);
    Runtime::instance()->enqueue((bh_opcode)$opcode, *operand, lhs, rhs);

    return *operand;
}

template <typename T>
multi_array<T> & operator$op (const T& lhs, multi_array<T>& rhs)
{
    multi_array<T>* operand = new multi_array<T>( rhs );
    operand->setTemp(true);
    Runtime::instance()->enqueue((bh_opcode)$opcode, *operand, lhs, rhs);

    return *operand;
}
%slurp
%end if
%end for

//
//  Unary operators such as:
//  Mapping "!a" to BH_NEGATE(t, a)
//
%for $op, $opcode, $optype, $opcount in $data
%if $optype == "operator.ext" and $opcode != "CUSTOM" and $opcount == 2

template <typename T>
multi_array<T> & operator$op (multi_array<T>& rhs)
{
    multi_array<T>* operand = new multi_array<T>(rhs);
    operand->setTemp(true);

    Runtime::instance()->enqueue((bh_opcode)$opcode, *operand, rhs);

    return *operand;
}
%slurp
%end if
%end for


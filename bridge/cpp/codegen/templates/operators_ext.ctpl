#slurp
#compiler-settings
directiveStartToken = %
#end compiler-settings
%slurp
//
//  Binary operators such as:
//  Mapping "a + b" to BH_ADD(t, a, b)
//  Mapping "a + 1.0" to BH_ADD(t, a, 1.0)
//  Mapping "1.0 + a" to BH_ADD(t, 1.0, a)
//
%for $op, $opcode, $optype, $opcount in $data
%if $optype == "operator.ext" and $opcode != "CUSTOM" and $opcount == 3

template <typename T>
multi_array<T>& operator$op (multi_array<T>& lhs, multi_array<T>& rhs)
{
    DEBUG_PRINT("> %ld operator$op %ld\n", lhs.getRank(), rhs.getRank());
    multi_array<T>* left    = &lhs;
    multi_array<T>* right   = &rhs;
    multi_array<T>* result; 

    if (compatible_shape(lhs, rhs)) {
        result = &Runtime::instance()->temp(lhs);
    } else {
        DEBUG_PRINT("> Incompatible shape, possibly broadcastable.\n");

        if (lhs.getRank() < rhs.getRank()) {    // Left-handside has lowest rank
            DEBUG_PRINT("> Creating view of left\n");
            left    = &Runtime::instance()->temp_view(lhs);
            right   = &rhs;
            if (!broadcast(lhs, rhs, *left)) {
                throw std::runtime_error("Failed broadcasting.");
            }
            DEBUG_PRINT("> Creating temp\n");
            result  = &Runtime::instance()->temp(*left);
        } else {                                // Right-handside has lowest rank
            DEBUG_PRINT("> Creating view of right\n");
            left    = &lhs;
            right   = &Runtime::instance()->temp_view(rhs);
            right->setTemp(true);
            if (!broadcast(rhs, lhs, *right)) {
                throw std::runtime_error("Failed broadcasting.");
            }
            DEBUG_PRINT("> Creating temp\n");
            result  = &Runtime::instance()->temp(*right);
        }
        
    }
    bh_pprint_array(&storage[left->getKey()]);
    bh_pprint_array(&storage[right->getKey()]);
    bh_pprint_array(&storage[result->getKey()]);
    Runtime::instance()->enqueue((bh_opcode)$opcode, *result, *left, *right);
    DEBUG_PRINT("< operator$op\n");
    return *result;
}

template <typename T>
multi_array<T> & operator$op (multi_array<T>& lhs, const T& rhs)
{
    multi_array<T>* result = &Runtime::instance()->temp(lhs);

    Runtime::instance()->enqueue((bh_opcode)$opcode, *result, lhs, rhs);

    return *result;
}

template <typename T>
multi_array<T> & operator$op (const T& lhs, multi_array<T>& rhs)
{
    multi_array<T>* result = &Runtime::instance()->temp(rhs);

    Runtime::instance()->enqueue((bh_opcode)$opcode, *result, lhs, rhs);

    return *result;
}
%slurp
%end if
%end for

//
//  Unary operators such as:
//  Mapping "!a" to BH_NEGATE(t, a)
//
%for $op, $opcode, $optype, $opcount in $data
%if $optype == "operator.ext" and $opcode != "CUSTOM" and $opcount == 2

template <typename T>
multi_array<T> & operator$op (multi_array<T>& rhs)
{
    multi_array<T>* result = &Runtime::instance()->temp(rhs);

    Runtime::instance()->enqueue((bh_opcode)$opcode, *result, rhs);

    return *result;
}
%slurp
%end if
%end for


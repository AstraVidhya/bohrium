#slurp
#compiler-settings
directiveStartToken = %
#end compiler-settings
%slurp

//
//  Internally defined operator overloads
//
%for $op, $opcode, $optype, $opcount in $data
%if $optype == "operator.int" and $opcode != "CUSTOM" and $opcount == 2

template <typename T>
Vector<T>& Vector<T>::operator $op ( const T rhs )
{
    //std::cout << *this << " $op " << rhs << std::endl;
    enqueue_ac( (bh_opcode)$opcode, *this, rhs );
    return *this;
}

template <typename T>
Vector<T>& Vector<T>::operator $op ( Vector<T> & rhs )
{
    //std::cout << *this << " $op " << rhs << std::endl;
    enqueue_aa( (bh_opcode)$opcode, *this, rhs );
    return *this;
}

%end if
%end for

%for $op, $opcode, $optype, $opcount in $data
%if $optype == "operator.int" and $opcode == "CUSTOM" and $opcount == 2

template <typename T>
Vector<T>& Vector<T>::operator $op ( const T rhs )
{
    //std::cout << *this << " $op " << rhs << std::endl;
    // TODO: implement
    return *this;
}

template <typename T>
Vector<T>& Vector<T>::operator $op ( Vector<T> & rhs )
{
    //std::cout << *this << " $op " << rhs << std::endl;
    //enqueue_aa( (bh_opcode)$opcode, *this, rhs );
    // TODO: implement
    return *this;
}

%end if
%end for


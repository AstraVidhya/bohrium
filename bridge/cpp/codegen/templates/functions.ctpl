#slurp
#compiler-settings
directiveStartToken = %
#end compiler-settings
%slurp
%include raw "codegen/templates/license.txt"

%include raw "codegen/templates/warn.txt"

#ifndef __BOHRIUM_BRIDGE_CPP_FUNCTIONS
#define __BOHRIUM_BRIDGE_CPP_FUNCTIONS
#include "bh.h"

namespace bh {
%slurp

%for $op, $opcode, $optype, $opcount, $typesigs in $data
%if $optype == "operator.fun"
%slurp
%if $opcount == 2
template <typename T>
multi_array<T>& $op (multi_array<T>& rhs)
{
    multi_array<T>* result = &Runtime::instance()->temp(rhs);

    Runtime::instance()->enqueue((bh_opcode)$opcode, *result, rhs);
    return *result;
}
%end if
%if $opcount == 3
template <typename T>
multi_array<T>& $op (multi_array<T>&lhs, multi_array<T>& rhs)
{
    multi_array<T>* result = &Runtime::instance()->temp(lhs);

    Runtime::instance()->enqueue((bh_opcode)$opcode, *result, lhs, rhs);
    return *result;
}

template <typename T>
multi_array<T>& $op (multi_array<T>&lhs, const T& rhs)
{
    multi_array<T>* result = &Runtime::instance()->temp(lhs);

    Runtime::instance()->enqueue((bh_opcode)$opcode, *result, lhs, rhs);
    return *result;
}

template <typename T>
T& $op (const T& lhs, const T& rhs)
{
    return lhs;
}

template <typename T>
T& $op (const T& lhs, const int& rhs)
{
    return lhs;
}


%end if
%end if
%end for

}
#endif


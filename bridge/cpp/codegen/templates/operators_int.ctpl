#slurp
#compiler-settings
directiveStartToken = %
#end compiler-settings
%slurp
//
//  Internally defined operator overloads
//
%for $op, $opcode, $optype, $opcount in $data
%if $optype == "operator.int" and $opcode != "CUSTOM" and $opcount == 3

template <typename T>
multi_array<T>& multi_array<T>::operator$op (const T& rhs)
{
    Runtime::instance()->enqueue((bh_opcode)$opcode, *this, *this, rhs);
    return *this;
}

template <typename T>
multi_array<T>& multi_array<T>::operator$op (multi_array<T>& rhs)
{
    multi_array<T>* input = &rhs;
                                            
    if (this->getRank() < input->getRank()) {       // This would be illogical...
        throw std::runtime_error("ARE YOU INSANE!");
    }

    if (!compatible_shape(*this, *input)) {         // We need to broadcast
        input = &Runtime::instance()->view(rhs);    // Create view pointing to rhs as base
        
        if (!broadcast(rhs, *this, *input)) {
            throw std::runtime_error("Right-handside is not broadcastable.");
        }
    }

    Runtime::instance()->enqueue((bh_opcode)$opcode, *this, *this, *input);
    return *this;
}
%slurp
%end if
%end for
%for $op, $opcode, $optype, $opcount in $data
%if $optype == "operator.int" and $opcode != "CUSTOM" and $opcount == 2

template <typename T>
multi_array<T>& multi_array<T>::operator$op (const T& rhs)
{
    Runtime::instance()->enqueue((bh_opcode)$opcode, *this, rhs);
    return *this;
}

template <typename T>
multi_array<T>& multi_array<T>::operator$op (multi_array<T>& rhs)
{
    multi_array<T>* input = &rhs;
                                            
    if (this->getRank() < input->getRank()) {       // This would be illogical...
        throw std::runtime_error("ARE YOU INSANE!");
    }

    if (!compatible_shape(*this, *input)) {         // We need to broadcast
        input = &Runtime::instance()->view(rhs);    // Create view pointing to rhs as base
        
        if (!broadcast(rhs, *this, *input)) {
            throw std::runtime_error("Right-handside is not broadcastable.");
        }
    }

    Runtime::instance()->enqueue((bh_opcode)$opcode, *this, *input);
    return *this;
}
%slurp
%end if
%end for


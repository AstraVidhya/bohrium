/*
This file is part of Bohrium and copyright (c) 2012 the Bohrium
team <http://www.bh107.org>.

Bohrium is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation, either version 3
of the License, or (at your option) any later version.

Bohrium is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the
GNU Lesser General Public License along with Bohrium.

If not, see <http://www.gnu.org/licenses/>.
*/
#include<bh.h>
#include<bh_flow.h>

using namespace std;

void bh_flow::add_access(bh_intp node_idx)
{
    bases[node_list[node_idx].view->base].push_back(node_idx);
}

bh_intp bh_flow::get_latest_conflicting_access(const bh_view *view, bool readonly)
{
    const vector<bh_intp> &same_base = bases[view->base];//All nodes with the same base as 'node_idx'
    for(vector<bh_intp>::const_reverse_iterator it = same_base.rbegin(); it != same_base.rend(); ++it)
    {
        const bh_flow_node &n = node_list[*it];
        if(readonly && n.readonly)
            continue;//No possible conflict when both is read only

        if(bh_view_overlap(n.view, view))
            return *it;
    }
    return -1;//No conflict
}


bh_flow::bh_flow(bh_intp ninstr, const bh_instruction *instr_list)
{
    this->ninstr = ninstr;
    this->instr_list = instr_list;

    for(bh_intp i=0; i<ninstr; i++)
    {
        const bh_instruction *instr = &instr_list[i];
        //The write node
        bh_flow_node wnode(0, false, i, &instr->operand[0]);

        //All nodes generated by the same instruction gets the same timestep
        bh_intp timestep = 0;

        //Generate read nodes
        bh_intp nnodes = 1; //Number of new nodes (incl. the write node)
        for(bh_intp o=1; o < bh_operands_in_instruction(instr); o++)
        {
            const bh_view *op = &instr->operand[o];
            if(bh_is_constant(op))
                continue;

            bh_flow_node rnode(0, true, i, op);

            bh_intp node_idx = get_latest_conflicting_access(op, true);
            if(node_idx >= 0)
            {
                const bh_flow_node &node = node_list[node_idx];

                //The new nodes must be placed after this conflicting node
                if(timestep <= node.timestep)
                    timestep = node.timestep+1;

                //If we have a perfect match, we add a flow edge since we
                //known that 'node' is a writing node
                if(bh_view_identical(node.view, op))
                    rnode.parents.insert(node_idx);
            }
            //Add the read node at make sure that the write node points to it
            //NB: we update the timestep later
            node_list.push_back(rnode);
            bh_intp rnode_idx = node_list.size()-1;
            wnode.parents.insert(rnode_idx);
            add_access(rnode_idx);
            nnodes++;
        }
        //Lets find the final timestep value
        bh_intp node_idx = get_latest_conflicting_access(wnode.view, false);
        if(node_idx >= 0)
        {
            const bh_flow_node &node = node_list[node_idx];
            if(timestep <= node.timestep)
                timestep = node.timestep+1;
        }
        node_list.push_back(wnode);
        add_access(node_list.size()-1);
        //Save the final timestep value
        for(vector<bh_flow_node>::iterator it = node_list.end()-nnodes;
            it != node_list.end(); it++)
        {
            it->timestep = timestep;
        }
    }
}

void bh_flow::pprint(void)
{
    char str[10000];
    bh_pprint_instr_list(instr_list, ninstr, str);
    printf("%s",str);

    printf("id:\ttime:\tR/W:\tparent:\tinstr:\n");
    bh_intp t = 0;//The current time step
    bool not_finished = true;
    while(not_finished)
    {
        not_finished = false;
        for(unsigned int i=0; i<node_list.size(); i++)
        {
            const bh_flow_node &n = node_list[i];
            if(n.timestep == t)
            {
                printf("%2u\t", i);
                printf("%2ld\t", n.timestep);
                if(n.readonly)
                    printf(" R\t");
                else
                    printf(" W\t");
                printf("[");
                for(set<bh_intp>::const_iterator p=n.parents.begin(); p!=n.parents.end(); p++)
                {
                    if(p == n.parents.begin())//First iteration
                        printf("%ld", *p);
                    else
                        printf(",%ld", *p);
                }
                printf("]\t");

                printf("%2ld-%s\t", n.instr_idx, bh_opcode_text(instr_list[n.instr_idx].opcode)+3);

                printf("\n");

                not_finished = true;//We found one thus there might be more
            }
        }
        t++;
    }
}



/*
This file is part of Bohrium and copyright (c) 2012 the Bohrium
team <http://www.bh107.org>.

Bohrium is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation, either version 3
of the License, or (at your option) any later version.

Bohrium is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the
GNU Lesser General Public License along with Bohrium.

If not, see <http://www.gnu.org/licenses/>.
*/
#include <bh.h>
#include <bh_flow.h>
#include <bh_vector.h>
#include <assert.h>
#include <iostream>
#include <string>
#include <iomanip>
#include <sstream>
#include <fstream>
#include <stdexcept>
using namespace std;

//Registrate access by the 'node_idx'
void bh_flow::add_access(bh_intp node_idx)
{
    const bh_flow_node &n = node_list[node_idx];
    bases[n.view->base].push_back(node_idx);
}

//Add accesses that conflicts with the 'node_idx' to 'conflicts'
void bh_flow::get_conflicting_access(bh_intp node_idx, set<bh_intp> &conflicts)
{
    //Search through all nodes with the same base as 'node_idx'
    const bh_flow_node &node = node_list[node_idx];
    const vector<bh_intp> &same_base = bases[node.view->base];

    //Iterate 'it' to where the 'node_idx' is in 'same_base'
    vector<bh_intp>::const_reverse_iterator it = same_base.rbegin();
    for(it = same_base.rbegin(); it != same_base.rend(); ++it)
    {
        if(*it == node_idx)
            break;
    }
    assert(it != same_base.rend());//'node_idx' must be found in 'same_base'

    //Now continue iterating through possible conflicts
    for(++it; it != same_base.rend(); ++it)
    {
        const bh_flow_node &n = node_list[*it];

        if(node.readonly && n.readonly)
            continue;//No possible conflict when both is read only

        if(bh_view_overlap(n.view, node.view))
        {
            assert(*it != node_idx);//We cannot conflict with ourself
            conflicts.insert(*it);
        }
    }
}

//Get the latest access that conflicts with 'view'
bh_intp bh_flow::get_latest_conflicting_access(const bh_view *view, bool readonly)
{
    //Search through all nodes with the same base as 'node_idx'
    const vector<bh_intp> &same_base = bases[view->base];
    for(vector<bh_intp>::const_reverse_iterator it = same_base.rbegin();
        it != same_base.rend(); ++it)
    {
        const bh_flow_node &n = node_list[*it];
        if(readonly && n.readonly)
            continue;//No possible conflict when both is read only

        if(bh_view_overlap(n.view, view))
            return *it;
    }
    return -1;//No conflict
}

//Create a new flow object based on an instruction list
bh_flow::bh_flow(bh_intp ninstr, const bh_instruction *instr_list)
{
    this->ninstr = ninstr;
    this->instr_list = instr_list;

    for(bh_intp i=0; i<ninstr; i++)
    {
        const bh_instruction *instr = &instr_list[i];
        //The write node
        bh_flow_node wnode(0, false, i, &instr->operand[0]);

        //All nodes generated by the same instruction gets the same timestep
        bh_intp timestep = 0;

        //Generate read nodes
        bh_intp nnodes = 1; //Number of new nodes (incl. the write node)
        for(bh_intp o=1; o < bh_operands_in_instruction(instr); o++)
        {
            const bh_view *op = &instr->operand[o];
            if(bh_is_constant(op))
                continue;

            bh_flow_node rnode(0, true, i, op);

            bh_intp node_idx = get_latest_conflicting_access(op, true);
            if(node_idx >= 0)
            {
                const bh_flow_node &node = node_list[node_idx];

                //The new nodes must be placed after this conflicting node
                if(timestep <= node.timestep)
                    timestep = node.timestep+1;

                //If we have a perfect match, we add a flow edge since we
                //known that 'node' is a writing node
                if(bh_view_identical(node.view, op))
                    rnode.parents.insert(node_idx);
            }
            //Add the read node at make sure that the write node points to it
            //NB: we update the timestep later
            node_list.push_back(rnode);
            bh_intp rnode_idx = node_list.size()-1;
            wnode.parents.insert(rnode_idx);
            add_access(rnode_idx);
            nnodes++;
        }
        //Lets find the final timestep value
        bh_intp node_idx = get_latest_conflicting_access(wnode.view, false);
        if(node_idx >= 0)
        {
            const bh_flow_node &node = node_list[node_idx];
            if(timestep <= node.timestep)
                timestep = node.timestep+1;
        }
        node_list.push_back(wnode);
        add_access(node_list.size()-1);
        //Save the final timestep value
        for(vector<bh_flow_node>::iterator it = node_list.end()-nnodes;
            it != node_list.end(); it++)
        {
            it->timestep = timestep;
        }
    }
    sub_dag_clustering();
}

//Fill the uninitialized 'bhir' based on the flow object
void bh_flow::bhir_fill(bh_ir *bhir)
{
    assert(bhir->dag_list == NULL);

    //A set of dependencies for each write-node (i.e. instruction) in the flow
    //An index in 'wnode' corresponds to a index in 'instr_list'
    vector<set<bh_intp> > wnodes(ninstr);

    //Map between flow and bhir sub-DAG indices
    map<bh_intp, bh_intp> dag_f2b;
    //Number of sub-DAGs
    map<bh_intp, bh_intp>::size_type ndags = 0;
    //Initiate the sub-DAGs
    for(vector<bh_flow_node>::size_type i=0; i<node_list.size(); ++i)
    {
        const bh_flow_node &n = node_list[i];
        if(n.sub_dag == -1)
        {
            throw runtime_error("All nodes must be assigned to a sub_dag (no -1 indices) "
                                "before calling bhir_fill()");
        }
        if(dag_f2b.count(n.sub_dag) == 0)
            dag_f2b[n.sub_dag] = ndags++;
    }
    //A set of dependencies for each sub-DAG in the bhir
    vector<set<bh_intp> > dag_deps(ndags);

    //A set of wnodes for each sub-DAG in the flow
    vector<set<bh_intp> > dag_nodes(ndags);

    //Compute dependencies both between nodes and sub-DAGs
    for(vector<bh_flow_node>::size_type i=0; i<node_list.size(); ++i)
    {
        const bh_flow_node &n = node_list[i];
        if(!n.readonly)//A write instruction
        {
            set<bh_intp> deps;
            //Check write conflicts
            get_conflicting_access(i, deps);
            //Check read conflicts
            for(set<bh_intp>::const_iterator p=n.parents.begin(); p!=n.parents.end(); ++p)
            {
                get_conflicting_access(*p, deps);
            }
            for(set<bh_intp>::const_iterator it = deps.begin(); it != deps.end(); it++)
            {
                const bh_flow_node &d = node_list[*it];
                if(n.sub_dag == d.sub_dag)//The dependency is within a sub-DAG
                {
                    if(n.instr_idx != d.instr_idx)//We cannot conflict with ourself
                        wnodes[n.instr_idx].insert(d.instr_idx);
                }
                else//The dependency is to another sub-DAG
                {
                    dag_deps[dag_f2b[n.sub_dag]].insert(dag_f2b[d.sub_dag]);
                }
            }
            dag_nodes[n.sub_dag].insert(n.instr_idx);
        }
    }
    //Allocate the DAG list
    bhir->ndag = ndags+1;//which includes the root DAG
    bhir->dag_list = (bh_dag*) bh_vector_create(sizeof(bh_dag), bhir->ndag, bhir->ndag);
    if(bhir->dag_list == NULL)
        throw std::bad_alloc();

    //Create the root DAG where all nodes a sub-DAGs
    {
        bh_dag *dag = &bhir->dag_list[0];
        dag->node_map = (bh_intp*) bh_vector_create(sizeof(bh_intp), ndags, ndags);
        if(dag->node_map == NULL)
            throw std::bad_alloc();
        for(map<bh_intp, bh_intp>::size_type i=0; i<ndags; ++i)
            dag->node_map[i] = (-1*(i+1)-1);
        dag->nnode = ndags;
        dag->tag = 0;
        dag->adjmat = bh_adjmat_create(ndags);
        if(dag->adjmat == NULL)
            throw std::bad_alloc();

        //Fill each row in the adjacency matrix with the dependencies between sub-DAGs
        for(vector<set<bh_intp> >::size_type i=0; i < ndags; i++)
        {
            const std::set<bh_intp> &deps = dag_deps[i];
            if(deps.size() > 0)
            {
                std::vector<bh_intp> sorted_vector(deps.begin(), deps.end());
                bh_error e = bh_adjmat_fill_empty_col(dag->adjmat, i,
                                                      deps.size(),
                                                      &sorted_vector[0]);
                if(e != BH_SUCCESS)
                    throw std::bad_alloc();
            }
        }
        if(bh_adjmat_finalize(dag->adjmat) != BH_SUCCESS)
            throw std::bad_alloc();
    }
    //Create all sub-DAGs
    for(vector<set<bh_intp> >::size_type dag_idx=0; dag_idx<dag_nodes.size(); ++dag_idx)
    {
        const set<bh_intp> &nodes = dag_nodes[dag_idx];
        bh_dag *dag = &bhir->dag_list[dag_idx+1];
        dag->node_map = (bh_intp*) bh_vector_create(sizeof(bh_intp), nodes.size(), nodes.size());
        if(dag->node_map == NULL)
            throw std::bad_alloc();
        dag->nnode = nodes.size();
        dag->tag = 0;
        dag->adjmat = bh_adjmat_create(nodes.size());
        if(dag->adjmat == NULL)
            throw std::bad_alloc();

        //Fill the adjmat sequentially starting at row zero
        bh_intp node_count = 0;
        map<bh_intp,bh_intp> wnodes_f2b;//flow to bhir index map
        for(set<bh_intp>::const_iterator it=nodes.begin(); it!=nodes.end(); it++)
        {
            const set<bh_intp> &deps = wnodes[*it];
            //Note that the order of 'it' is ascending thus the topological order is preserved.
            dag->node_map[node_count] = *it;
            //Mapping from flow index to node index within the sub-DAG.
            wnodes_f2b[*it] = node_count;

            if(deps.size() > 0)
            {
                //Convert flow indices to indices in the local sub-DAG
                vector<bh_intp> sorted_vector;
                for(set<bh_intp>::iterator d = deps.begin(); d != deps.end(); d++)
                {
                    sorted_vector.push_back(wnodes_f2b[*d]);
                }
                bh_error e = bh_adjmat_fill_empty_col(dag->adjmat, node_count,
                                                      sorted_vector.size(),
                                                      &sorted_vector[0]);
                if(e != BH_SUCCESS)
                    throw std::bad_alloc();
            }
            node_count++;
        }
        if(bh_adjmat_finalize(dag->adjmat) != BH_SUCCESS)
            throw std::bad_alloc();
    }
}

//Assign a node to a sub-DAG
void bh_flow::set_sub_dag(bh_intp sub_dag, bh_intp node_idx)
{
    sub_dags[sub_dag].insert(node_idx);
}

//Cluster the flow object into sub-DAGs suitable as kernals
void bh_flow::sub_dag_clustering(void)
{
    //Assign all nodes to the sub-DAG that equals their timestep
    for(vector<bh_flow_node>::iterator n=node_list.begin(); n!=node_list.end(); n++)
        n->sub_dag = n->timestep;
}

//Pretty print the flow object to 'buf'
void bh_flow::sprint(char *buf)
{
    stringstream str;
    str << "id:\ttime:\tR/W:\tparent:\tinstr:" << endl;
    bh_intp t = 0;//The current time step
    bool not_finished = true;
    while(not_finished)
    {
        not_finished = false;
        for(unsigned int i=0; i<node_list.size(); i++)
        {
            const bh_flow_node &n = node_list[i];
            if(n.timestep == t)
            {
                str << i << "\t";
                str << n.timestep << "\t";
                if(n.readonly)
                    str << " R ";
                else
                    str << " W ";
                str << "\t" << "[";
                for(set<bh_intp>::const_iterator p=n.parents.begin(); p!=n.parents.end(); ++p)
                {
                    if(p != n.parents.begin())//Not the first iteration
                        str << ",";
                    str << *p;
                }
                str << "]\t";

                str << n.instr_idx << "." << (bh_opcode_text(instr_list[n.instr_idx].opcode)+3);

                str << endl;

                not_finished = true;//We found one thus there might be more
            }
        }
        t++;
    }
    //Write the stream to a C string
    strcpy(buf, str.str().c_str());
}

//Pretty print the flow object to stdout
void bh_flow::pprint(void)
{
    char buf[100000];
    sprint(buf);
    puts(buf);
}

//Pretty print the flow object to file 'filename'
void bh_flow::fprint(const char* filename)
{
    char buf[100000];
    FILE *file;
    file = fopen(filename, "w");
    sprint(buf);
    fputs(buf, file);
    fclose(file);
}

// Write the flow object in the DOT format.
void bh_flow::dot(const char* filename)
{
    ofstream fs(filename);

    fs << "digraph {" << std::endl;
    fs << "compound=true;" << std::endl;

    //Write all nodes and conflict edges
    map<const bh_base *, vector<bh_intp> >::const_iterator b;
    for(b=bases.begin(); b != bases.end(); b++)
    {
        fs << "subgraph clusterBASE" << b->first << " {" << endl;
        fs << "label=\"" << b->first << "\";" << endl;

        //Define all nodes
        vector<bh_intp>::const_iterator v,w;
        for(v=b->second.begin(); v != b->second.end(); v++)
        {
            const bh_flow_node &n = node_list[*v];
            fs << "n" << *v << "[label=\"" << *v << "T" << n.timestep;
            if(n.readonly)
                fs << "R";
            else
                fs << "W";
            fs << n.sub_dag;
            fs << "_" << bh_opcode_text(instr_list[n.instr_idx].opcode)+3;
            fs << "(" << n.instr_idx << ")\"";
            fs << " shape=box style=filled,rounded";
            if(n.sub_dag >= 0)
                fs << " colorscheme=paired12 fillcolor=" << n.sub_dag%12+1;
            fs << "]" << endl;

        }
        //Write invisible edges in order to get correct layout
        for(v=b->second.begin(); v != b->second.end()-1; v++)
        {
            fs << "n" << *v << " -> n" << *(v+1) << "[style=\"invis\"];" << endl;
        }

        //Write conflict edges
        for(v=b->second.begin(); v != b->second.end()-1; v++)
        {
            for(w=v+1; w != b->second.end(); w++)
            {
                if(!bh_view_identical(node_list[*v].view, node_list[*w].view))
                    fs << "n" << *v << " -> n" << *w << " [color=red];" << endl;
            }
        }
        fs << "}" << endl;
    }
    //Write all flow edges
    for(vector<bh_flow_node>::size_type i=0; i<node_list.size(); i++)
    {
        const bh_flow_node &n = node_list[i];
        set<bh_intp>::const_iterator it;
        for(it=n.parents.begin(); it != n.parents.end(); it++)
        {

            assert(n.timestep >= node_list[*it].timestep);
            fs << "{";
     //       if(n.timestep == node_list[*it].timestep)
     //           fs << "rank=same; ";
            fs << "n" << *it << " -> n" << i << ";";
            fs << "}" << endl;
        }
    }
    fs << "}" << std::endl;
    fs.close();
}



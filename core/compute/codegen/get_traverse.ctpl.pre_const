#slurp
#compiler-settings
directiveStartToken = %
#end compiler-settings
%slurp
#include <cphvb.h>
#include "get_traverse.hpp"
#include "traverse.hpp"
#include "functors.hpp"

traverse_ptr get_traverse( cphvb_instruction *instr ) {

    // Poly contains a unique value, pairing an opcode with its function signature.
    // All in one nicely switchable value.
    const long int poly = (cphvb_operands(instr->opcode) == 3) ?
                            instr->opcode +
                            (instr->operand[0]->type    << 8)
                            +(instr->operand[1]->type   << 12)
                            +(instr->operand[2]->type   << 16):

                            instr->opcode +
                            (instr->operand[0]->type    << 8)
                            +(instr->operand[1]->type   << 12);

    switch(poly) {

        %for $case in $cases
        %if $case.opcount == 2
        case ${case.opcode} + (${case.op1} << 8) +(${case.op2} <<12):
            return &traverse_${case.opcount}<${case.ftypes}, ${case.fname}_functor<${case.ftypes}> >;
            break;
        %else
        case ${case.opcode} + (${case.op1} << 8) +(${case.op2} <<12) + (${case.op3} <<16):
            return &traverse_${case.opcount}<${case.ftypes}, ${case.fname}_functor<${case.ftypes}> >;
            break;
        %end if
        %end for

        default:
            return NULL;

    }

}


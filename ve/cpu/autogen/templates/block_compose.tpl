#compiler-settings
directiveStartToken= %
#end compiler-settings
%slurp
#include "block.hpp"
//
//  NOTE: This file is autogenerated based on the tac-definition.
//        You should therefore not edit it manually.
//
using namespace std;
namespace bohrium{
namespace engine{
namespace cpu{

/**
 *  Compose a block based on the instruction-nodes within a dag.
 */
bool Block::compose()
{
    if (this->dag.nnode<1) {
        fprintf(stderr, "Got an empty dag. This cannot be right...\n");
        return false;
    }
    bool compose_res = compose(0, this->dag.nnode-1);

    return compose_res;
}

/**
 *  Compose a block based on the instruction-nodes within a dag.
 *  Starting from and including node_start to and including node_end.
 */
bool Block::compose(bh_intp node_start, bh_intp node_end)
{
    DEBUG(TAG, "compose("<< node_start <<", "<< node_end << ") : node_span(" << ((node_end-node_start)+1) << ")");
    if (this->dag.nnode<1) {
        fprintf(stderr, "Got an empty dag. This cannot be right...\n");
        return false;
    }
    
    // Reset metadata
    length      = 0; // The length of the block
    noperands   = 0; // The number of operands
    omask       = 0; // And the operation mask
    symbol      = "";
    symbol_text = "";

    size_t pc = 0;
    for (int node_idx=node_start; node_idx<=node_end; ++node_idx, ++pc, ++length) {
        
        if (dag.node_map[node_idx] <0) {
            fprintf(stderr, "Code-generation for subgraphs is not supported yet.\n");
            return false;
        }

        this->instr[pc] = &this->ir.instr_list[dag.node_map[node_idx]];
        bh_instruction& instr = *this->instr[pc];

        uint32_t out=0, in1=0, in2=0;

        //
        // Program packing: output argument
        // NOTE: All but BH_NONE has an output which is an array
        if (instr.opcode != BH_NONE) {
            out = this->add_operand(instr, 0);
        }

        //
        // Program packing; operator, operand and input argument(s).
        switch (instr.opcode) {    // [OPCODE_SWITCH]

            %for $opcode, $operation, $operator, $nin in $operations
            case $opcode:
                %if $opcode == 'BH_RANDOM'
                // This one requires special-handling... what a beauty...
                in1 = ++(this->noperands);                // Input
                this->scope[in1].const_data = &(instr.constant.value.r123.start);
                this->scope[in1].data       = &(this->scope[in1].const_data);
                this->scope[in1].etype      = UINT64;
                this->scope[in1].nelem      = 1;
                this->scope[in1].ndim       = 1;
                this->scope[in1].start      = 0;
                this->scope[in1].shape      = instr.operand[1].shape;
                this->scope[in1].shape[0]   = 1;
                this->scope[in1].stride     = instr.operand[1].stride;
                this->scope[in1].stride[0]  = 0;

                this->scope[in1].layout     = CONSTANT;

                in2 = ++(this->noperands);
                this->scope[in2].const_data = &(instr.constant.value.r123.key);
                this->scope[in2].data       = &(this->scope[in2].const_data);
                this->scope[in2].etype      = UINT64;
                this->scope[in2].nelem      = 1;
                this->scope[in2].ndim       = 0;
                this->scope[in2].start      = 0;
                this->scope[in2].shape      = instr.operand[2].shape;
                this->scope[in2].shape[0]   = 1;
                this->scope[in2].stride     = instr.operand[2].stride;
                this->scope[in2].stride[0]  = 0;
                this->scope[in2].layout     = CONSTANT;

                %else if 'ACCUMULATE' in $opcode or 'REDUCE' in $opcode
                in1 = this->add_operand(instr, 1);

                in2 = ++(this->noperands);
                this->scope[in2].const_data = &(instr.constant.value.uint64);
                this->scope[in2].data       = &(this->scope[in2].const_data);
                this->scope[in2].etype      = UINT64;
                this->scope[in2].nelem      = 1;
                this->scope[in2].ndim       = 1;
                this->scope[in2].start      = 0;
                this->scope[in2].shape      = instr.operand[2].shape;
                this->scope[in2].shape[0]   = 1;
                this->scope[in2].stride     = instr.operand[2].stride;
                this->scope[in2].stride[0]  = 0;
                this->scope[in2].layout     = CONSTANT;

                %else
                %if nin >= 1
                in1 = this->add_operand(instr, 1);
                %end if
                %if nin >= 2
                in2 = this->add_operand(instr, 2);
                %end if
                %end if

                this->program[pc].op    = $operation;  // TAC
                this->program[pc].oper  = $operator;
                this->program[pc].out   = out;
                this->program[pc].in1   = in1;
                this->program[pc].in2   = in2;
            
                this->omask |= $operation;    // Operationmask
                break;
            %end for

            default:
                if (instr.opcode>=BH_MAX_OPCODE_ID) {   // Handle extensions here

                    this->program[pc].op   = EXTENSION; // TODO: Be clever about it
                    this->program[pc].oper = EXTENSION_OPERATOR;
                    this->program[pc].out  = 0;
                    this->program[pc].in1  = 0;
                    this->program[pc].in2  = 0;

                    this->omask |= EXTENSION;
                    //cout << "Extension method." << endl;
                    break;

                } else {
                    fprintf(stderr, "Block::compose: Err=[Unsupported instruction] {\n");
                    bh_pprint_instr(&instr);
                    fprintf(stderr, "}\n");
                    return false;
                }
        }
    }
    DEBUG(TAG, "compose(SUCCESS)");
    return true;
}

}}}

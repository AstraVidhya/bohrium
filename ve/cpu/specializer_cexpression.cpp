#include "specializer.hpp"
//
//  NOTE: This file is autogenerated based on the tac-definition.
//        You should therefore not edit it manually.
//
using namespace std;
namespace bohrium {
namespace engine {
namespace cpu {

//
// NOTE: This function relies on the posix entension for positional arguments
// to print format string.
//
string Specializer::cexpression(const Block& block, size_t tac_idx)
{
    tac_t& tac  = block.program[tac_idx];
    ETYPE etype = block.symbol_table.table[tac.out].etype;

    string expr_text;

    switch(tac.oper) {
        case ABSOLUTE:            
            
            expr_text = "*a%1$d_current = *a%2$d_current < 0.0 ? -*a%2$d_current: *a%2$d_current"; break;
            break;
        case ADD:            
            switch (tac.op) {
                case ZIP:
                    expr_text = "*a%1$d_current = *a%2$d_current + *a%3$d_current"; break;
                case SCAN:
                    expr_text = "state += *a%2$d_current; *a%1$d_current = state"; break;
                case REDUCE:
                    expr_text = "state += *tmp_current"; break;
                default:
                    expr_text = "__ERR_UNS_OPER__"; break;
            }            
            break;
        case ARCCOS:            
            
            switch(etype) {
                case COMPLEX128: expr_text = "*a%1$d_current = cacos( *a%2$d_current )"; break;
                case COMPLEX64: expr_text = "*a%1$d_current = cacosf( *a%2$d_current )"; break;
                default: expr_text = "*a%1$d_current = acos( *a%2$d_current )"; break;
            }
            break;
        case ARCCOSH:            
            
            switch(etype) {
                case COMPLEX128: expr_text = "*a%1$d_current = cacosh( *a%2$d_current )"; break;
                case COMPLEX64: expr_text = "*a%1$d_current = cacoshf( *a%2$d_current )"; break;
                default: expr_text = "*a%1$d_current = acosh( *a%2$d_current )"; break;
            }
            break;
        case ARCSIN:            
            
            switch(etype) {
                case COMPLEX128: expr_text = "*a%1$d_current = casin( *a%2$d_current )"; break;
                case COMPLEX64: expr_text = "*a%1$d_current = casinf( *a%2$d_current )"; break;
                default: expr_text = "*a%1$d_current = asin( *a%2$d_current )"; break;
            }
            break;
        case ARCSINH:            
            
            switch(etype) {
                case COMPLEX128: expr_text = "*a%1$d_current = casinh( *a%2$d_current )"; break;
                case COMPLEX64: expr_text = "*a%1$d_current = casinhf( *a%2$d_current )"; break;
                default: expr_text = "*a%1$d_current = asinh( *a%2$d_current )"; break;
            }
            break;
        case ARCTAN:            
            
            switch(etype) {
                case COMPLEX128: expr_text = "*a%1$d_current = catan( *a%2$d_current )"; break;
                case COMPLEX64: expr_text = "*a%1$d_current = catanf( *a%2$d_current )"; break;
                default: expr_text = "*a%1$d_current = atan( *a%2$d_current )"; break;
            }
            break;
        case ARCTAN2:            
            
            expr_text = "*a%1$d_current = atan2( *a%2$d_current, *a%3$d_current )"; break;
            break;
        case ARCTANH:            
            
            switch(etype) {
                case COMPLEX128: expr_text = "*a%1$d_current = catanh( *a%2$d_current )"; break;
                case COMPLEX64: expr_text = "*a%1$d_current = catanhf( *a%2$d_current )"; break;
                default: expr_text = "*a%1$d_current = atanh( *a%2$d_current )"; break;
            }
            break;
        case BITWISE_AND:            
            switch (tac.op) {
                case ZIP:
                    expr_text = "*a%1$d_current = *a%2$d_current & *a%3$d_current"; break;
                case REDUCE:
                    expr_text = "state &= *tmp_current"; break;
                default:
                    expr_text = "__ERR_UNS_OPER__"; break;
            }            
            break;
        case BITWISE_OR:            
            switch (tac.op) {
                case ZIP:
                    expr_text = "*a%1$d_current = *a%2$d_current | *a%3$d_current"; break;
                case REDUCE:
                    expr_text = "state = state | *tmp_current"; break;
                default:
                    expr_text = "__ERR_UNS_OPER__"; break;
            }            
            break;
        case BITWISE_XOR:            
            switch (tac.op) {
                case ZIP:
                    expr_text = "*a%1$d_current = *a%2$d_current ^ *a%3$d_current"; break;
                case REDUCE:
                    expr_text = "state = state ^ *tmp_current"; break;
                default:
                    expr_text = "__ERR_UNS_OPER__"; break;
            }            
            break;
        case CEIL:            
            
            expr_text = "*a%1$d_current = ceil( *a%2$d_current )"; break;
            break;
        case COS:            
            
            switch(etype) {
                case COMPLEX128: expr_text = "*a%1$d_current = ccos( *a%2$d_current )"; break;
                case COMPLEX64: expr_text = "*a%1$d_current = ccosf( *a%2$d_current )"; break;
                default: expr_text = "*a%1$d_current = cos( *a%2$d_current )"; break;
            }
            break;
        case COSH:            
            
            switch(etype) {
                case COMPLEX128: expr_text = "*a%1$d_current = ccosh( *a%2$d_current )"; break;
                case COMPLEX64: expr_text = "*a%1$d_current = ccoshf( *a%2$d_current )"; break;
                default: expr_text = "*a%1$d_current = cosh( *a%2$d_current )"; break;
            }
            break;
        case DISCARD:            
            
            expr_text = "__ERROR__SYSTEM_DISCARD_SHOULD_NOT_BE_HERE__"; break;
            break;
        case DIVIDE:            
            
            expr_text = "*a%1$d_current = *a%2$d_current / *a%3$d_current"; break;
            break;
        case EQUAL:            
            
            expr_text = "*a%1$d_current = *a%2$d_current == *a%3$d_current"; break;
            break;
        case EXP:            
            
            switch(etype) {
                case COMPLEX128: expr_text = "*a%1$d_current = cexp( *a%2$d_current )"; break;
                case COMPLEX64: expr_text = "*a%1$d_current = cexpf( *a%2$d_current )"; break;
                default: expr_text = "*a%1$d_current = exp( *a%2$d_current )"; break;
            }
            break;
        case EXP2:            
            
            switch(etype) {
                case COMPLEX128: expr_text = "*a%1$d_current = cpow( 2, *a%2$d_current )"; break;
                case COMPLEX64: expr_text = "*a%1$d_current = cpowf( 2, *a%2$d_current )"; break;
                default: expr_text = "*a%1$d_current = pow( 2, *a%2$d_current )"; break;
            }
            break;
        case EXPM1:            
            
            expr_text = "*a%1$d_current = expm1( *a%2$d_current )"; break;
            break;
        case EXTENSION_OPERATOR:            
            
            expr_text = "__ERROR__EXTENSION_EXTENSION_OPERATOR_SHOULD_NOT_BE_HERE__"; break;
            break;
        case FLOOD:            
            
            expr_text = "__ERROR__GENERATOR_FLOOD_NOT_IMLEMENTED__"; break;
            break;
        case FLOOR:            
            
            expr_text = "*a%1$d_current = floor( *a%2$d_current )"; break;
            break;
        case FREE:            
            
            expr_text = "__ERROR__SYSTEM_FREE_SHOULD_NOT_BE_HERE__"; break;
            break;
        case GREATER:            
            
            expr_text = "*a%1$d_current = *a%2$d_current > *a%3$d_current"; break;
            break;
        case GREATER_EQUAL:            
            
            expr_text = "*a%1$d_current = *a%2$d_current >= *a%3$d_current"; break;
            break;
        case IDENTITY:            
            
            expr_text = "*a%1$d_current = *a%2$d_current"; break;
            break;
        case IMAG:            
            
            switch(etype) {
                case FLOAT32: expr_text = "*a%1$d_current = cimagf(*a%2$d_current)"; break;
                default: expr_text = "*a%1$d_current = cimag(*a%2$d_current)"; break;
            }
            break;
        case INVERT:            
            
            expr_text = "*a%1$d_current = ~*a%2$d_current"; break;
            break;
        case ISINF:            
            
            expr_text = "*a%1$d_current = isinf(*a%2$d_current)"; break;
            break;
        case ISNAN:            
            
            expr_text = "*a%1$d_current = isnan(*a%2$d_current)"; break;
            break;
        case LEFT_SHIFT:            
            
            expr_text = "*a%1$d_current = (*a%2$d_current) << (*a%3$d_current)"; break;
            break;
        case LESS:            
            
            expr_text = "*a%1$d_current = *a%2$d_current < *a%3$d_current"; break;
            break;
        case LESS_EQUAL:            
            
            expr_text = "*a%1$d_current = *a%2$d_current <= *a%3$d_current"; break;
            break;
        case LOG:            
            
            switch(etype) {
                case COMPLEX128: expr_text = "*a%1$d_current = clog( *a%2$d_current )"; break;
                case COMPLEX64: expr_text = "*a%1$d_current = clogf( *a%2$d_current )"; break;
                default: expr_text = "*a%1$d_current = log( *a%2$d_current )"; break;
            }
            break;
        case LOG10:            
            
            switch(etype) {
                case COMPLEX128: expr_text = "*a%1$d_current = clog( *a%2$d_current )/log(10)"; break;
                case COMPLEX64: expr_text = "*a%1$d_current = clogf( *a%2$d_current )/log(10)"; break;
                default: expr_text = "*a%1$d_current = log( *a%2$d_current )/log(10)"; break;
            }
            break;
        case LOG1P:            
            
            expr_text = "*a%1$d_current = log1p( *a%2$d_current )"; break;
            break;
        case LOG2:            
            
            expr_text = "*a%1$d_current = log2( *a%2$d_current )"; break;
            break;
        case LOGICAL_AND:            
            switch (tac.op) {
                case ZIP:
                    expr_text = "*a%1$d_current = *a%2$d_current && *a%3$d_current"; break;
                case REDUCE:
                    expr_text = "state = state && *tmp_current"; break;
                default:
                    expr_text = "__ERR_UNS_OPER__"; break;
            }            
            break;
        case LOGICAL_NOT:            
            
            expr_text = "*a%1$d_current = !*a%2$d_current"; break;
            break;
        case LOGICAL_OR:            
            switch (tac.op) {
                case ZIP:
                    expr_text = "*a%1$d_current = *a%2$d_current || *a%3$d_current"; break;
                case REDUCE:
                    expr_text = "state = state || *tmp_current"; break;
                default:
                    expr_text = "__ERR_UNS_OPER__"; break;
            }            
            break;
        case LOGICAL_XOR:            
            switch (tac.op) {
                case ZIP:
                    expr_text = "*a%1$d_current = (!*a%2$d_current != !*a%3$d_current)"; break;
                case REDUCE:
                    expr_text = "state = !state != !*tmp_current"; break;
                default:
                    expr_text = "__ERR_UNS_OPER__"; break;
            }            
            break;
        case MAXIMUM:            
            switch (tac.op) {
                case ZIP:
                    expr_text = "*a%1$d_current = *a%2$d_current < *a%3$d_current ? *a%3$d_current : *a%2$d_current"; break;
                case REDUCE:
                    expr_text = "state = state < *tmp_current ? *tmp_current : state"; break;
                default:
                    expr_text = "__ERR_UNS_OPER__"; break;
            }            
            break;
        case MINIMUM:            
            switch (tac.op) {
                case ZIP:
                    expr_text = "*a%1$d_current = *a%2$d_current < *a%3$d_current ? *a%2$d_current : *a%3$d_current"; break;
                case REDUCE:
                    expr_text = "state = state < *tmp_current ? state : *tmp_current"; break;
                default:
                    expr_text = "__ERR_UNS_OPER__"; break;
            }            
            break;
        case MOD:            
            
            expr_text = "*a%1$d_current = *a%2$d_current - floor(*a%2$d_current / *a%3$d_current) * *a%3$d_current"; break;
            break;
        case MULTIPLY:            
            switch (tac.op) {
                case ZIP:
                    expr_text = "*a%1$d_current = *a%2$d_current * *a%3$d_current"; break;
                case SCAN:
                    expr_text = "state *= *a%2$d_current; *a%1$d_current = state"; break;
                case REDUCE:
                    expr_text = "state *= *tmp_current"; break;
                default:
                    expr_text = "__ERR_UNS_OPER__"; break;
            }            
            break;
        case NONE:            
            
            expr_text = "__ERROR__SYSTEM_NONE_SHOULD_NOT_BE_HERE__"; break;
            break;
        case NOT_EQUAL:            
            
            expr_text = "*a%1$d_current = *a%2$d_current != *a%3$d_current"; break;
            break;
        case POWER:            
            
            switch(etype) {
                case COMPLEX128: expr_text = "*a%1$d_current = cpow( *a%2$d_current, *a%3$d_current )"; break;
                case COMPLEX64: expr_text = "*a%1$d_current = cpowf( *a%2$d_current, *a%3$d_current )"; break;
                default: expr_text = "*a%1$d_current = pow( *a%2$d_current, *a%3$d_current )"; break;
            }
            break;
        case RANDOM:            
            
            expr_text = "__ERROR__GENERATOR_RANDOM_NOT_IMLEMENTED__"; break;
            break;
        case RANGE:            
            
            expr_text = "*a%1$d_current = state"; break;
            break;
        case REAL:            
            
            switch(etype) {
                case FLOAT32: expr_text = "*a%1$d_current = crealf(*a%2$d_current)"; break;
                default: expr_text = "*a%1$d_current = creal(*a%2$d_current)"; break;
            }
            break;
        case RIGHT_SHIFT:            
            
            expr_text = "*a%1$d_current = (*a%2$d_current) >> (*a%3$d_current)"; break;
            break;
        case RINT:            
            
            expr_text = "*a%1$d_current = (*a%2$d_current > 0.0) ? floor(*a%2$d_current + 0.5) : ceil(*a%2$d_current - 0.5)"; break;
            break;
        case SIN:            
            
            switch(etype) {
                case COMPLEX128: expr_text = "*a%1$d_current = csin( *a%2$d_current )"; break;
                case COMPLEX64: expr_text = "*a%1$d_current = csinf( *a%2$d_current )"; break;
                default: expr_text = "*a%1$d_current = sin( *a%2$d_current )"; break;
            }
            break;
        case SINH:            
            
            switch(etype) {
                case COMPLEX128: expr_text = "*a%1$d_current = csinh( *a%2$d_current )"; break;
                case COMPLEX64: expr_text = "*a%1$d_current = csinhf( *a%2$d_current )"; break;
                default: expr_text = "*a%1$d_current = sinh( *a%2$d_current )"; break;
            }
            break;
        case SQRT:            
            
            switch(etype) {
                case COMPLEX128: expr_text = "*a%1$d_current = csqrt( *a%2$d_current )"; break;
                case COMPLEX64: expr_text = "*a%1$d_current = csqrtf( *a%2$d_current )"; break;
                default: expr_text = "*a%1$d_current = sqrt( *a%2$d_current )"; break;
            }
            break;
        case SUBTRACT:            
            
            expr_text = "*a%1$d_current = *a%2$d_current - *a%3$d_current"; break;
            break;
        case SYNC:            
            
            expr_text = "__ERROR__SYSTEM_SYNC_SHOULD_NOT_BE_HERE__"; break;
            break;
        case TAN:            
            
            switch(etype) {
                case COMPLEX128: expr_text = "*a%1$d_current = ctan( *a%2$d_current )"; break;
                case COMPLEX64: expr_text = "*a%1$d_current = ctanf( *a%2$d_current )"; break;
                default: expr_text = "*a%1$d_current = tan( *a%2$d_current )"; break;
            }
            break;
        case TANH:            
            
            switch(etype) {
                case COMPLEX128: expr_text = "*a%1$d_current = ctanh( *a%2$d_current )"; break;
                case COMPLEX64: expr_text = "*a%1$d_current = ctanhf( *a%2$d_current )"; break;
                default: expr_text = "*a%1$d_current = tanh( *a%2$d_current )"; break;
            }
            break;
        case TRUNC:            
            
            expr_text = "*a%1$d_current = trunc( *a%2$d_current )"; break;
            break;
    }

    switch(utils::tac_noperands(tac)) {
        case 3:
            return utils::string_format(
                expr_text, 
                block.operand_map.find(tac.out)->second, 
                block.operand_map.find(tac.in1)->second,
                block.operand_map.find(tac.in2)->second
            );
        case 2:
            return utils::string_format(
                expr_text, 
                block.operand_map.find(tac.out)->second,
                block.operand_map.find(tac.in1)->second
            );
        case 1:
            return utils::string_format(
                expr_text,
                block.operand_map.find(tac.out)->second
            );
        default:
            return expr_text;
    }
}    

}}}

#include "specializer.hpp"
//
//  NOTE: This file is autogenerated based on the tac-definition.
//        You should therefore not edit it manually.
//
using namespace std;
namespace bohrium {
namespace engine {
namespace cpu {

string Specializer::cexpression(Block& block, size_t tac_idx)
{
    tac_t& tac  = block.program[tac_idx];
    ETYPE etype = block.scope[tac.out].type;
    string expr_text;

    switch(tac.oper) {
        case ABSOLUTE:            
            expr_text = "*a%d_current = *a%d_current < 0.0 ? -*a%d_current: *a%d_current"; break;
            break;
        case ADD:            
            switch (tac.op) {
                case ZIP:
                    expr_text = "*a%d_current = *a%d_current + *a%d_current"; break;
                case SCAN:
                    expr_text = "state += *a%d_current; *a%d_current = state"; break;
                case REDUCE:
                    expr_text = "state += *tmp_current"; break;
                default:
                    expr_text = "__ERR_UNS_OPER__"; break;
            }            
            break;
        case ARCCOS:            
            switch(etype) {
                case COMPLEX128: expr_text = "*a%d_current = cacos( *a%d_current )"; break;
                case COMPLEX64: expr_text = "*a%d_current = cacosf( *a%d_current )"; break;
                default: expr_text = "*a%d_current = acos( *a%d_current )"; break;
            }
            break;
        case ARCCOSH:            
            switch(etype) {
                case COMPLEX128: expr_text = "*a%d_current = cacosh( *a%d_current )"; break;
                case COMPLEX64: expr_text = "*a%d_current = cacoshf( *a%d_current )"; break;
                default: expr_text = "*a%d_current = acosh( *a%d_current )"; break;
            }
            break;
        case ARCSIN:            
            switch(etype) {
                case COMPLEX128: expr_text = "*a%d_current = casin( *a%d_current )"; break;
                case COMPLEX64: expr_text = "*a%d_current = casinf( *a%d_current )"; break;
                default: expr_text = "*a%d_current = asin( *a%d_current )"; break;
            }
            break;
        case ARCSINH:            
            switch(etype) {
                case COMPLEX128: expr_text = "*a%d_current = casinh( *a%d_current )"; break;
                case COMPLEX64: expr_text = "*a%d_current = casinhf( *a%d_current )"; break;
                default: expr_text = "*a%d_current = asinh( *a%d_current )"; break;
            }
            break;
        case ARCTAN:            
            switch(etype) {
                case COMPLEX128: expr_text = "*a%d_current = catan( *a%d_current )"; break;
                case COMPLEX64: expr_text = "*a%d_current = catanf( *a%d_current )"; break;
                default: expr_text = "*a%d_current = atan( *a%d_current )"; break;
            }
            break;
        case ARCTAN2:            
            expr_text = "*a%d_current = atan2( *a%d_current, *a%d_current )"; break;
            break;
        case ARCTANH:            
            switch(etype) {
                case COMPLEX128: expr_text = "*a%d_current = catanh( *a%d_current )"; break;
                case COMPLEX64: expr_text = "*a%d_current = catanhf( *a%d_current )"; break;
                default: expr_text = "*a%d_current = atanh( *a%d_current )"; break;
            }
            break;
        case BITWISE_AND:            
            switch (tac.op) {
                case ZIP:
                    expr_text = "*a%d_current = *a%d_current & *a%d_current"; break;
                case REDUCE:
                    expr_text = "state &= *tmp_current"; break;
                default:
                    expr_text = "__ERR_UNS_OPER__"; break;
            }            
            break;
        case BITWISE_OR:            
            switch (tac.op) {
                case ZIP:
                    expr_text = "*a%d_current = *a%d_current | *a%d_current"; break;
                case REDUCE:
                    expr_text = "state = state | *tmp_current"; break;
                default:
                    expr_text = "__ERR_UNS_OPER__"; break;
            }            
            break;
        case BITWISE_XOR:            
            switch (tac.op) {
                case ZIP:
                    expr_text = "*a%d_current = *a%d_current ^ *a%d_current"; break;
                case REDUCE:
                    expr_text = "state = state ^ *tmp_current"; break;
                default:
                    expr_text = "__ERR_UNS_OPER__"; break;
            }            
            break;
        case CEIL:            
            expr_text = "*a%d_current = ceil( *a%d_current )"; break;
            break;
        case COS:            
            switch(etype) {
                case COMPLEX128: expr_text = "*a%d_current = ccos( *a%d_current )"; break;
                case COMPLEX64: expr_text = "*a%d_current = ccosf( *a%d_current )"; break;
                default: expr_text = "*a%d_current = cos( *a%d_current )"; break;
            }
            break;
        case COSH:            
            switch(etype) {
                case COMPLEX128: expr_text = "*a%d_current = ccosh( *a%d_current )"; break;
                case COMPLEX64: expr_text = "*a%d_current = ccoshf( *a%d_current )"; break;
                default: expr_text = "*a%d_current = cosh( *a%d_current )"; break;
            }
            break;
        case DIVIDE:            
            expr_text = "*a%d_current = *a%d_current / *a%d_current"; break;
            break;
        case EQUAL:            
            expr_text = "*a%d_current = *a%d_current == *a%d_current"; break;
            break;
        case EXP:            
            switch(etype) {
                case COMPLEX128: expr_text = "*a%d_current = cexp( *a%d_current )"; break;
                case COMPLEX64: expr_text = "*a%d_current = cexpf( *a%d_current )"; break;
                default: expr_text = "*a%d_current = exp( *a%d_current )"; break;
            }
            break;
        case EXP2:            
            switch(etype) {
                case COMPLEX128: expr_text = "*a%d_current = cpow( 2, *a%d_current )"; break;
                case COMPLEX64: expr_text = "*a%d_current = cpowf( 2, *a%d_current )"; break;
                default: expr_text = "*a%d_current = pow( 2, *a%d_current )"; break;
            }
            break;
        case EXPM1:            
            expr_text = "*a%d_current = expm1( *a%d_current )"; break;
            break;
        case FLOOR:            
            expr_text = "*a%d_current = floor( *a%d_current )"; break;
            break;
        case GREATER:            
            expr_text = "*a%d_current = *a%d_current > *a%d_current"; break;
            break;
        case GREATER_EQUAL:            
            expr_text = "*a%d_current = *a%d_current >= *a%d_current"; break;
            break;
        case IDENTITY:            
            expr_text = "*a%d_current = *a%d_current"; break;
            break;
        case IMAG:            
            switch(etype) {
                case FLOAT32: expr_text = "*a%d_current = cimagf(*a%d_current)"; break;
                default: expr_text = "*a%d_current = cimag(*a%d_current)"; break;
            }
            break;
        case INVERT:            
            expr_text = "*a%d_current = ~*a%d_current"; break;
            break;
        case ISINF:            
            expr_text = "*a%d_current = isinf(*a%d_current)"; break;
            break;
        case ISNAN:            
            expr_text = "*a%d_current = isnan(*a%d_current)"; break;
            break;
        case LEFT_SHIFT:            
            expr_text = "*a%d_current = (*a%d_current) << (*a%d_current)"; break;
            break;
        case LESS:            
            expr_text = "*a%d_current = *a%d_current < *a%d_current"; break;
            break;
        case LESS_EQUAL:            
            expr_text = "*a%d_current = *a%d_current <= *a%d_current"; break;
            break;
        case LOG:            
            switch(etype) {
                case COMPLEX128: expr_text = "*a%d_current = clog( *a%d_current )"; break;
                case COMPLEX64: expr_text = "*a%d_current = clogf( *a%d_current )"; break;
                default: expr_text = "*a%d_current = log( *a%d_current )"; break;
            }
            break;
        case LOG10:            
            switch(etype) {
                case COMPLEX128: expr_text = "*a%d_current = clog( *a%d_current )/log(10)"; break;
                case COMPLEX64: expr_text = "*a%d_current = clogf( *a%d_current )/log(10)"; break;
                default: expr_text = "*a%d_current = log( *a%d_current )/log(10)"; break;
            }
            break;
        case LOG1P:            
            expr_text = "*a%d_current = log1p( *a%d_current )"; break;
            break;
        case LOG2:            
            expr_text = "*a%d_current = log2( *a%d_current )"; break;
            break;
        case LOGICAL_AND:            
            switch (tac.op) {
                case ZIP:
                    expr_text = "*a%d_current = *a%d_current && *a%d_current"; break;
                case REDUCE:
                    expr_text = "state = state && *tmp_current"; break;
                default:
                    expr_text = "__ERR_UNS_OPER__"; break;
            }            
            break;
        case LOGICAL_NOT:            
            expr_text = "*a%d_current = !*a%d_current"; break;
            break;
        case LOGICAL_OR:            
            switch (tac.op) {
                case ZIP:
                    expr_text = "*a%d_current = *a%d_current || *a%d_current"; break;
                case REDUCE:
                    expr_text = "state = state || *tmp_current"; break;
                default:
                    expr_text = "__ERR_UNS_OPER__"; break;
            }            
            break;
        case LOGICAL_XOR:            
            switch (tac.op) {
                case ZIP:
                    expr_text = "*a%d_current = (!*a%d_current != !*a%d_current)"; break;
                case REDUCE:
                    expr_text = "state = !state != !*tmp_current"; break;
                default:
                    expr_text = "__ERR_UNS_OPER__"; break;
            }            
            break;
        case MAXIMUM:            
            switch (tac.op) {
                case ZIP:
                    expr_text = "*a%d_current = *a%d_current < *a%d_current ? *a%d_current : *a%d_current"; break;
                case REDUCE:
                    expr_text = "state = state < *tmp_current ? *tmp_current : state"; break;
                default:
                    expr_text = "__ERR_UNS_OPER__"; break;
            }            
            break;
        case MINIMUM:            
            switch (tac.op) {
                case ZIP:
                    expr_text = "*a%d_current = *a%d_current < *a%d_current ? *a%d_current : *a%d_current"; break;
                case REDUCE:
                    expr_text = "state = state < *tmp_current ? state : *tmp_current"; break;
                default:
                    expr_text = "__ERR_UNS_OPER__"; break;
            }            
            break;
        case MOD:            
            expr_text = "*a%d_current = *a%d_current - floor(*a%d_current / *a%d_current) * *a%d_current"; break;
            break;
        case MULTIPLY:            
            switch (tac.op) {
                case ZIP:
                    expr_text = "*a%d_current = *a%d_current * *a%d_current"; break;
                case SCAN:
                    expr_text = "state *= *a%d_current; *a%d_current = state"; break;
                case REDUCE:
                    expr_text = "state *= *tmp_current"; break;
                default:
                    expr_text = "__ERR_UNS_OPER__"; break;
            }            
            break;
        case NOT_EQUAL:            
            expr_text = "*a%d_current = *a%d_current != *a%d_current"; break;
            break;
        case POWER:            
            switch(etype) {
                case COMPLEX128: expr_text = "*a%d_current = cpow( *a%d_current, *a%d_current )"; break;
                case COMPLEX64: expr_text = "*a%d_current = cpowf( *a%d_current, *a%d_current )"; break;
                default: expr_text = "*a%d_current = *a%d_current / *a%d_current"; break;
            }
            break;
        case RANGE:            
            expr_text = "*a%d_current = state"; break;
            break;
        case REAL:            
            switch(etype) {
                case FLOAT32: expr_text = "*a%d_current = crealf(*a%d_current)"; break;
                default: expr_text = "*a%d_current = creal(*a%d_current)"; break;
            }
            break;
        case RIGHT_SHIFT:            
            expr_text = "*a%d_current = (*a%d_current) >> (*a%d_current)"; break;
            break;
        case RINT:            
            expr_text = "*a%d_current = (*a%d_current > 0.0) ? floor(*a%d_current + 0.5) : ceil(*a%d_current - 0.5)"; break;
            break;
        case SIN:            
            switch(etype) {
                case COMPLEX128: expr_text = "*a%d_current = csin( *a%d_current )"; break;
                case COMPLEX64: expr_text = "*a%d_current = csinf( *a%d_current )"; break;
                default: expr_text = "*a%d_current = sin( *a%d_current )"; break;
            }
            break;
        case SINH:            
            switch(etype) {
                case COMPLEX128: expr_text = "*a%d_current = csinh( *a%d_current )"; break;
                case COMPLEX64: expr_text = "*a%d_current = csinhf( *a%d_current )"; break;
                default: expr_text = "*a%d_current = sinh( *a%d_current )"; break;
            }
            break;
        case SQRT:            
            switch(etype) {
                case COMPLEX128: expr_text = "*a%d_current = csqrt( *a%d_current )"; break;
                case COMPLEX64: expr_text = "*a%d_current = csqrtf( *a%d_current )"; break;
                default: expr_text = "*a%d_current = sqrt( *a%d_current )"; break;
            }
            break;
        case SUBTRACT:            
            expr_text = "*a%d_current = *a%d_current - *a%d_current"; break;
            break;
        case TAN:            
            switch(etype) {
                case COMPLEX128: expr_text = "*a%d_current = ctan( *a%d_current )"; break;
                case COMPLEX64: expr_text = "*a%d_current = ctanf( *a%d_current )"; break;
                default: expr_text = "*a%d_current = tan( *a%d_current )"; break;
            }
            break;
        case TANH:            
            switch(etype) {
                case COMPLEX128: expr_text = "*a%d_current = ctanh( *a%d_current )"; break;
                case COMPLEX64: expr_text = "*a%d_current = ctanhf( *a%d_current )"; break;
                default: expr_text = "*a%d_current = tanh( *a%d_current )"; break;
            }
            break;
        case TRUNC:            
            expr_text = "*a%d_current = trunc( *a%d_current )"; break;
            break;
    }

    switch(utils::tac_noperands(tac)) {
        case 3:
            return utils::string_format(expr_text, tac.out, tac.in1, tac.in2);
        case 2:
            return utils::string_format(expr_text, tac.out, tac.in1);
        case 1:
            return utils::string_format(expr_text, tac.out);
        default:
            return expr_text;
    }
}    

}}}
